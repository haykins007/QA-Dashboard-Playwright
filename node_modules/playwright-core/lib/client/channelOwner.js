"use strict";
<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var channelOwner_exports = {};
__export(channelOwner_exports, {
  ChannelOwner: () => ChannelOwner
});
module.exports = __toCommonJS(channelOwner_exports);
var import_eventEmitter = require("./eventEmitter");
var import_validator = require("../protocol/validator");
var import_clientStackTrace = require("./clientStackTrace");
var import_stackTrace = require("../utils/isomorphic/stackTrace");
class ChannelOwner extends import_eventEmitter.EventEmitter {
  constructor(parent, type, guid, initializer) {
    const connection = parent instanceof ChannelOwner ? parent._connection : parent;
    super(connection._platform);
    this._objects = /* @__PURE__ */ new Map();
    this._eventToSubscriptionMapping = /* @__PURE__ */ new Map();
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChannelOwner = void 0;
var _eventEmitter = require("./eventEmitter");
var _validator = require("../protocol/validator");
var _clientStackTrace = require("./clientStackTrace");
var _stackTrace = require("../utils/isomorphic/stackTrace");
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ChannelOwner extends _eventEmitter.EventEmitter {
  constructor(parent, type, guid, initializer) {
    const connection = parent instanceof ChannelOwner ? parent._connection : parent;
    super(connection._platform);
    this._connection = void 0;
    this._parent = void 0;
    this._objects = new Map();
    this._type = void 0;
    this._guid = void 0;
    this._channel = void 0;
    this._initializer = void 0;
    this._logger = void 0;
    this._instrumentation = void 0;
    this._eventToSubscriptionMapping = new Map();
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._isInternalType = false;
    this._wasCollected = false;
    this.setMaxListeners(0);
    this._connection = connection;
    this._type = type;
    this._guid = guid;
<<<<<<< HEAD
    this._parent = parent instanceof ChannelOwner ? parent : void 0;
=======
    this._parent = parent instanceof ChannelOwner ? parent : undefined;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._instrumentation = this._connection._instrumentation;
    this._connection._objects.set(guid, this);
    if (this._parent) {
      this._parent._objects.set(guid, this);
      this._logger = this._parent._logger;
    }
<<<<<<< HEAD
    this._channel = this._createChannel(new import_eventEmitter.EventEmitter(connection._platform));
=======
    this._channel = this._createChannel(new _eventEmitter.EventEmitter(connection._platform));
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._initializer = initializer;
  }
  markAsInternalType() {
    this._isInternalType = true;
  }
  _setEventToSubscriptionMapping(mapping) {
    this._eventToSubscriptionMapping = mapping;
  }
  _updateSubscription(event, enabled) {
    const protocolEvent = this._eventToSubscriptionMapping.get(String(event));
    if (protocolEvent) {
      this._wrapApiCall(async () => {
<<<<<<< HEAD
        await this._channel.updateSubscription({ event: protocolEvent, enabled });
      }, true).catch(() => {
      });
    }
  }
  on(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
=======
        await this._channel.updateSubscription({
          event: protocolEvent,
          enabled
        });
      }, true).catch(() => {});
    }
  }
  on(event, listener) {
    if (!this.listenerCount(event)) this._updateSubscription(event, true);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    super.on(event, listener);
    return this;
  }
  addListener(event, listener) {
<<<<<<< HEAD
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
=======
    if (!this.listenerCount(event)) this._updateSubscription(event, true);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    super.addListener(event, listener);
    return this;
  }
  prependListener(event, listener) {
<<<<<<< HEAD
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
=======
    if (!this.listenerCount(event)) this._updateSubscription(event, true);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    super.prependListener(event, listener);
    return this;
  }
  off(event, listener) {
    super.off(event, listener);
<<<<<<< HEAD
    if (!this.listenerCount(event))
      this._updateSubscription(event, false);
=======
    if (!this.listenerCount(event)) this._updateSubscription(event, false);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    return this;
  }
  removeListener(event, listener) {
    super.removeListener(event, listener);
<<<<<<< HEAD
    if (!this.listenerCount(event))
      this._updateSubscription(event, false);
=======
    if (!this.listenerCount(event)) this._updateSubscription(event, false);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    return this;
  }
  _adopt(child) {
    child._parent._objects.delete(child._guid);
    this._objects.set(child._guid, child);
    child._parent = this;
  }
  _dispose(reason) {
<<<<<<< HEAD
    if (this._parent)
      this._parent._objects.delete(this._guid);
    this._connection._objects.delete(this._guid);
    this._wasCollected = reason === "gc";
    for (const object of [...this._objects.values()])
      object._dispose(reason);
=======
    // Clean up from parent and connection.
    if (this._parent) this._parent._objects.delete(this._guid);
    this._connection._objects.delete(this._guid);
    this._wasCollected = reason === 'gc';

    // Dispose all children.
    for (const object of [...this._objects.values()]) object._dispose(reason);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._objects.clear();
  }
  _debugScopeState() {
    return {
      _guid: this._guid,
<<<<<<< HEAD
      objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
=======
      objects: Array.from(this._objects.values()).map(o => o._debugScopeState())
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    };
  }
  _validatorToWireContext() {
    return {
      tChannelImpl: tChannelImplToWire,
<<<<<<< HEAD
      binary: this._connection.rawBuffers() ? "buffer" : "toBase64",
=======
      binary: this._connection.rawBuffers() ? 'buffer' : 'toBase64',
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      isUnderTest: () => this._platform.isUnderTest()
    };
  }
  _createChannel(base) {
    const channel = new Proxy(base, {
      get: (obj, prop) => {
<<<<<<< HEAD
        if (typeof prop === "string") {
          const validator = (0, import_validator.maybeFindValidator)(this._type, prop, "Params");
          if (validator) {
            return async (params) => {
              return await this._wrapApiCall(async (apiZone) => {
                const validatedParams = validator(params, "", this._validatorToWireContext());
                if (!apiZone.isInternal && !apiZone.reported) {
=======
        if (typeof prop === 'string') {
          const validator = (0, _validator.maybeFindValidator)(this._type, prop, 'Params');
          if (validator) {
            return async params => {
              return await this._wrapApiCall(async apiZone => {
                const validatedParams = validator(params, '', this._validatorToWireContext());
                if (!apiZone.isInternal && !apiZone.reported) {
                  // Reporting/tracing/logging this api call for the first time.
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
                  apiZone.params = params;
                  apiZone.reported = true;
                  this._instrumentation.onApiCallBegin(apiZone);
                  logApiCall(this._platform, this._logger, `=> ${apiZone.apiName} started`);
                  return await this._connection.sendMessageToServer(this, prop, validatedParams, apiZone.apiName, apiZone.frames, apiZone.stepId);
                }
<<<<<<< HEAD
                return await this._connection.sendMessageToServer(this, prop, validatedParams, void 0, [], void 0);
=======
                // Since this api call is either internal, or has already been reported/traced once,
                // passing undefined apiName will avoid an extra unneeded tracing entry.
                return await this._connection.sendMessageToServer(this, prop, validatedParams, undefined, [], undefined);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
              });
            };
          }
        }
        return obj[prop];
      }
    });
    channel._object = this;
    return channel;
  }
  async _wrapApiCall(func, isInternal) {
    const logger = this._logger;
    const existingApiZone = this._platform.zones.current().data();
<<<<<<< HEAD
    if (existingApiZone)
      return await func(existingApiZone);
    if (isInternal === void 0)
      isInternal = this._isInternalType;
    const stackTrace = (0, import_clientStackTrace.captureLibraryStackTrace)(this._platform);
    const apiZone = { apiName: stackTrace.apiName, frames: stackTrace.frames, isInternal, reported: false, userData: void 0, stepId: void 0 };
=======
    if (existingApiZone) return await func(existingApiZone);
    if (isInternal === undefined) isInternal = this._isInternalType;
    const stackTrace = (0, _clientStackTrace.captureLibraryStackTrace)(this._platform);
    const apiZone = {
      apiName: stackTrace.apiName,
      frames: stackTrace.frames,
      isInternal,
      reported: false,
      userData: undefined,
      stepId: undefined
    };
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    try {
      const result = await this._platform.zones.current().push(apiZone).run(async () => await func(apiZone));
      if (!isInternal) {
        logApiCall(this._platform, logger, `<= ${apiZone.apiName} succeeded`);
        this._instrumentation.onApiCallEnd(apiZone);
      }
      return result;
    } catch (e) {
<<<<<<< HEAD
      const innerError = (this._platform.showInternalStackFrames() || this._platform.isUnderTest()) && e.stack ? "\n<inner error>\n" + e.stack : "";
      if (apiZone.apiName && !apiZone.apiName.includes("<anonymous>"))
        e.message = apiZone.apiName + ": " + e.message;
      const stackFrames = "\n" + (0, import_stackTrace.stringifyStackFrames)(stackTrace.frames).join("\n") + innerError;
      if (stackFrames.trim())
        e.stack = e.message + stackFrames;
      else
        e.stack = "";
=======
      const innerError = (this._platform.showInternalStackFrames() || this._platform.isUnderTest()) && e.stack ? '\n<inner error>\n' + e.stack : '';
      if (apiZone.apiName && !apiZone.apiName.includes('<anonymous>')) e.message = apiZone.apiName + ': ' + e.message;
      const stackFrames = '\n' + (0, _stackTrace.stringifyStackFrames)(stackTrace.frames).join('\n') + innerError;
      if (stackFrames.trim()) e.stack = e.message + stackFrames;else e.stack = '';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (!isInternal) {
        apiZone.error = e;
        logApiCall(this._platform, logger, `<= ${apiZone.apiName} failed`);
        this._instrumentation.onApiCallEnd(apiZone);
      }
      throw e;
    }
  }
  _toImpl() {
<<<<<<< HEAD
    return this._connection.toImpl?.(this);
  }
  toJSON() {
=======
    var _this$_connection$toI, _this$_connection;
    return (_this$_connection$toI = (_this$_connection = this._connection).toImpl) === null || _this$_connection$toI === void 0 ? void 0 : _this$_connection$toI.call(_this$_connection, this);
  }
  toJSON() {
    // Jest's expect library tries to print objects sometimes.
    // RPC objects can contain links to lots of other objects,
    // which can cause jest to crash. Let's help it out
    // by just returning the important values.
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    return {
      _type: this._type,
      _guid: this._guid
    };
  }
}
<<<<<<< HEAD
function logApiCall(platform, logger, message) {
  if (logger && logger.isEnabled("api", "info"))
    logger.log("api", "info", message, [], { color: "cyan" });
  platform.log("api", message);
}
function tChannelImplToWire(names, arg, path, context) {
  if (arg._object instanceof ChannelOwner && (names === "*" || names.includes(arg._object._type)))
    return { guid: arg._object._guid };
  throw new import_validator.ValidationError(`${path}: expected channel ${names.toString()}`);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChannelOwner
});
=======
exports.ChannelOwner = ChannelOwner;
function logApiCall(platform, logger, message) {
  if (logger && logger.isEnabled('api', 'info')) logger.log('api', 'info', message, [], {
    color: 'cyan'
  });
  platform.log('api', message);
}
function tChannelImplToWire(names, arg, path, context) {
  if (arg._object instanceof ChannelOwner && (names === '*' || names.includes(arg._object._type))) return {
    guid: arg._object._guid
  };
  throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
