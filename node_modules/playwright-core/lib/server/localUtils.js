"use strict";
<<<<<<< HEAD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var localUtils_exports = {};
__export(localUtils_exports, {
  addStackToTracingNoReply: () => addStackToTracingNoReply,
  harClose: () => harClose,
  harLookup: () => harLookup,
  harOpen: () => harOpen,
  harUnzip: () => harUnzip,
  traceDiscarded: () => traceDiscarded,
  tracingStarted: () => tracingStarted,
  zip: () => zip
});
module.exports = __toCommonJS(localUtils_exports);
var import_fs = __toESM(require("fs"));
var import_os = __toESM(require("os"));
var import_path = __toESM(require("path"));
var import_crypto = require("./utils/crypto");
var import_harBackend = require("./harBackend");
var import_manualPromise = require("../utils/isomorphic/manualPromise");
var import_zipFile = require("./utils/zipFile");
var import_zipBundle = require("../zipBundle");
var import_traceUtils = require("../utils/isomorphic/traceUtils");
var import_assert = require("../utils/isomorphic/assert");
var import_fileUtils = require("./utils/fileUtils");
async function zip(stackSessions, params) {
  const promise = new import_manualPromise.ManualPromise();
  const zipFile = new import_zipBundle.yazl.ZipFile();
  zipFile.on("error", (error) => promise.reject(error));
  const addFile = (file, name) => {
    try {
      if (import_fs.default.statSync(file).isFile())
        zipFile.addFile(file, name);
    } catch (e) {
    }
  };
  for (const entry of params.entries)
    addFile(entry.value, entry.name);
  const stackSession = params.stacksId ? stackSessions.get(params.stacksId) : void 0;
  if (stackSession?.callStacks.length) {
    await stackSession.writer;
    if (process.env.PW_LIVE_TRACE_STACKS) {
      zipFile.addFile(stackSession.file, "trace.stacks");
    } else {
      const buffer = Buffer.from(JSON.stringify((0, import_traceUtils.serializeClientSideCallMetadata)(stackSession.callStacks)));
      zipFile.addBuffer(buffer, "trace.stacks");
    }
  }
  if (params.includeSources) {
    const sourceFiles = /* @__PURE__ */ new Set();
    for (const { stack } of stackSession?.callStacks || []) {
      if (!stack)
        continue;
      for (const { file } of stack)
        sourceFiles.add(file);
    }
    for (const sourceFile of sourceFiles)
      addFile(sourceFile, "resources/src@" + await (0, import_crypto.calculateSha1)(sourceFile) + ".txt");
  }
  if (params.mode === "write") {
    await import_fs.default.promises.mkdir(import_path.default.dirname(params.zipFile), { recursive: true });
    zipFile.end(void 0, () => {
      zipFile.outputStream.pipe(import_fs.default.createWriteStream(params.zipFile)).on("close", () => promise.resolve()).on("error", (error) => promise.reject(error));
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addStackToTracingNoReply = addStackToTracingNoReply;
exports.harClose = harClose;
exports.harLookup = harLookup;
exports.harOpen = harOpen;
exports.harUnzip = harUnzip;
exports.traceDiscarded = traceDiscarded;
exports.tracingStarted = tracingStarted;
exports.zip = zip;
var _fs = _interopRequireDefault(require("fs"));
var _os = _interopRequireDefault(require("os"));
var _path = _interopRequireDefault(require("path"));
var _crypto = require("./utils/crypto");
var _harBackend = require("./harBackend");
var _manualPromise = require("../utils/isomorphic/manualPromise");
var _zipFile = require("./utils/zipFile");
var _zipBundle = require("../zipBundle");
var _traceUtils = require("../utils/isomorphic/traceUtils");
var _assert = require("../utils/isomorphic/assert");
var _fileUtils = require("./utils/fileUtils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

async function zip(stackSessions, params) {
  const promise = new _manualPromise.ManualPromise();
  const zipFile = new _zipBundle.yazl.ZipFile();
  zipFile.on('error', error => promise.reject(error));
  const addFile = (file, name) => {
    try {
      if (_fs.default.statSync(file).isFile()) zipFile.addFile(file, name);
    } catch (e) {}
  };
  for (const entry of params.entries) addFile(entry.value, entry.name);

  // Add stacks and the sources.
  const stackSession = params.stacksId ? stackSessions.get(params.stacksId) : undefined;
  if (stackSession !== null && stackSession !== void 0 && stackSession.callStacks.length) {
    await stackSession.writer;
    if (process.env.PW_LIVE_TRACE_STACKS) {
      zipFile.addFile(stackSession.file, 'trace.stacks');
    } else {
      const buffer = Buffer.from(JSON.stringify((0, _traceUtils.serializeClientSideCallMetadata)(stackSession.callStacks)));
      zipFile.addBuffer(buffer, 'trace.stacks');
    }
  }

  // Collect sources from stacks.
  if (params.includeSources) {
    const sourceFiles = new Set();
    for (const {
      stack
    } of (stackSession === null || stackSession === void 0 ? void 0 : stackSession.callStacks) || []) {
      if (!stack) continue;
      for (const {
        file
      } of stack) sourceFiles.add(file);
    }
    for (const sourceFile of sourceFiles) addFile(sourceFile, 'resources/src@' + (await (0, _crypto.calculateSha1)(sourceFile)) + '.txt');
  }
  if (params.mode === 'write') {
    // New file, just compress the entries.
    await _fs.default.promises.mkdir(_path.default.dirname(params.zipFile), {
      recursive: true
    });
    zipFile.end(undefined, () => {
      zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on('close', () => promise.resolve()).on('error', error => promise.reject(error));
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    });
    await promise;
    await deleteStackSession(stackSessions, params.stacksId);
    return;
  }
<<<<<<< HEAD
  const tempFile = params.zipFile + ".tmp";
  await import_fs.default.promises.rename(params.zipFile, tempFile);
  import_zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
=======

  // File already exists. Repack and add new entries.
  const tempFile = params.zipFile + '.tmp';
  await _fs.default.promises.rename(params.zipFile, tempFile);
  _zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    if (err) {
      promise.reject(err);
      return;
    }
<<<<<<< HEAD
    (0, import_assert.assert)(inZipFile);
    let pendingEntries = inZipFile.entryCount;
    inZipFile.on("entry", (entry) => {
      inZipFile.openReadStream(entry, (err2, readStream) => {
        if (err2) {
          promise.reject(err2);
=======
    (0, _assert.assert)(inZipFile);
    let pendingEntries = inZipFile.entryCount;
    inZipFile.on('entry', entry => {
      inZipFile.openReadStream(entry, (err, readStream) => {
        if (err) {
          promise.reject(err);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
          return;
        }
        zipFile.addReadStream(readStream, entry.fileName);
        if (--pendingEntries === 0) {
<<<<<<< HEAD
          zipFile.end(void 0, () => {
            zipFile.outputStream.pipe(import_fs.default.createWriteStream(params.zipFile)).on("close", () => {
              import_fs.default.promises.unlink(tempFile).then(() => {
                promise.resolve();
              }).catch((error) => promise.reject(error));
=======
          zipFile.end(undefined, () => {
            zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on('close', () => {
              _fs.default.promises.unlink(tempFile).then(() => {
                promise.resolve();
              }).catch(error => promise.reject(error));
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
            });
          });
        }
      });
    });
  });
  await promise;
  await deleteStackSession(stackSessions, params.stacksId);
}
async function deleteStackSession(stackSessions, stacksId) {
<<<<<<< HEAD
  const session = stacksId ? stackSessions.get(stacksId) : void 0;
  if (!session)
    return;
  await session.writer;
  if (session.tmpDir)
    await (0, import_fileUtils.removeFolders)([session.tmpDir]);
=======
  const session = stacksId ? stackSessions.get(stacksId) : undefined;
  if (!session) return;
  await session.writer;
  if (session.tmpDir) await (0, _fileUtils.removeFolders)([session.tmpDir]);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  stackSessions.delete(stacksId);
}
async function harOpen(harBackends, params) {
  let harBackend;
<<<<<<< HEAD
  if (params.file.endsWith(".zip")) {
    const zipFile = new import_zipFile.ZipFile(params.file);
    const entryNames = await zipFile.entries();
    const harEntryName = entryNames.find((e) => e.endsWith(".har"));
    if (!harEntryName)
      return { error: "Specified archive does not have a .har file" };
    const har = await zipFile.read(harEntryName);
    const harFile = JSON.parse(har.toString());
    harBackend = new import_harBackend.HarBackend(harFile, null, zipFile);
  } else {
    const harFile = JSON.parse(await import_fs.default.promises.readFile(params.file, "utf-8"));
    harBackend = new import_harBackend.HarBackend(harFile, import_path.default.dirname(params.file), null);
  }
  harBackends.set(harBackend.id, harBackend);
  return { harId: harBackend.id };
}
async function harLookup(harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (!harBackend)
    return { action: "error", message: `Internal error: har was not opened` };
=======
  if (params.file.endsWith('.zip')) {
    const zipFile = new _zipFile.ZipFile(params.file);
    const entryNames = await zipFile.entries();
    const harEntryName = entryNames.find(e => e.endsWith('.har'));
    if (!harEntryName) return {
      error: 'Specified archive does not have a .har file'
    };
    const har = await zipFile.read(harEntryName);
    const harFile = JSON.parse(har.toString());
    harBackend = new _harBackend.HarBackend(harFile, null, zipFile);
  } else {
    const harFile = JSON.parse(await _fs.default.promises.readFile(params.file, 'utf-8'));
    harBackend = new _harBackend.HarBackend(harFile, _path.default.dirname(params.file), null);
  }
  harBackends.set(harBackend.id, harBackend);
  return {
    harId: harBackend.id
  };
}
async function harLookup(harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (!harBackend) return {
    action: 'error',
    message: `Internal error: har was not opened`
  };
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  return await harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest);
}
async function harClose(harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (harBackend) {
    harBackends.delete(harBackend.id);
    harBackend.dispose();
  }
}
async function harUnzip(params) {
<<<<<<< HEAD
  const dir = import_path.default.dirname(params.zipFile);
  const zipFile = new import_zipFile.ZipFile(params.zipFile);
  for (const entry of await zipFile.entries()) {
    const buffer = await zipFile.read(entry);
    if (entry === "har.har")
      await import_fs.default.promises.writeFile(params.harFile, buffer);
    else
      await import_fs.default.promises.writeFile(import_path.default.join(dir, entry), buffer);
  }
  zipFile.close();
  await import_fs.default.promises.unlink(params.zipFile);
}
async function tracingStarted(stackSessions, params) {
  let tmpDir = void 0;
  if (!params.tracesDir)
    tmpDir = await import_fs.default.promises.mkdtemp(import_path.default.join(import_os.default.tmpdir(), "playwright-tracing-"));
  const traceStacksFile = import_path.default.join(params.tracesDir || tmpDir, params.traceName + ".stacks");
  stackSessions.set(traceStacksFile, { callStacks: [], file: traceStacksFile, writer: Promise.resolve(), tmpDir });
  return { stacksId: traceStacksFile };
=======
  const dir = _path.default.dirname(params.zipFile);
  const zipFile = new _zipFile.ZipFile(params.zipFile);
  for (const entry of await zipFile.entries()) {
    const buffer = await zipFile.read(entry);
    if (entry === 'har.har') await _fs.default.promises.writeFile(params.harFile, buffer);else await _fs.default.promises.writeFile(_path.default.join(dir, entry), buffer);
  }
  zipFile.close();
  await _fs.default.promises.unlink(params.zipFile);
}
async function tracingStarted(stackSessions, params) {
  let tmpDir = undefined;
  if (!params.tracesDir) tmpDir = await _fs.default.promises.mkdtemp(_path.default.join(_os.default.tmpdir(), 'playwright-tracing-'));
  const traceStacksFile = _path.default.join(params.tracesDir || tmpDir, params.traceName + '.stacks');
  stackSessions.set(traceStacksFile, {
    callStacks: [],
    file: traceStacksFile,
    writer: Promise.resolve(),
    tmpDir
  });
  return {
    stacksId: traceStacksFile
  };
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
}
async function traceDiscarded(stackSessions, params) {
  await deleteStackSession(stackSessions, params.stacksId);
}
async function addStackToTracingNoReply(stackSessions, params) {
  for (const session of stackSessions.values()) {
    session.callStacks.push(params.callData);
    if (process.env.PW_LIVE_TRACE_STACKS) {
      session.writer = session.writer.then(() => {
<<<<<<< HEAD
        const buffer = Buffer.from(JSON.stringify((0, import_traceUtils.serializeClientSideCallMetadata)(session.callStacks)));
        return import_fs.default.promises.writeFile(session.file, buffer);
      });
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addStackToTracingNoReply,
  harClose,
  harLookup,
  harOpen,
  harUnzip,
  traceDiscarded,
  tracingStarted,
  zip
});
=======
        const buffer = Buffer.from(JSON.stringify((0, _traceUtils.serializeClientSideCallMetadata)(session.callStacks)));
        return _fs.default.promises.writeFile(session.file, buffer);
      });
    }
  }
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
