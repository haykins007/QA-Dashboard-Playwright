"use strict";
<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chat_exports = {};
__export(chat_exports, {
  Chat: () => Chat,
  asString: () => asString
});
module.exports = __toCommonJS(chat_exports);
var import_transport = require("../transport");
class Chat {
  constructor(wsEndpoint) {
    this._history = [];
    this._chatSinks = /* @__PURE__ */ new Map();
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chat = void 0;
exports.asString = asString;
var _transport = require("../transport");
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Chat {
  constructor(wsEndpoint) {
    this._history = [];
    this._connectionPromise = void 0;
    this._chatSinks = new Map();
    this._wsEndpoint = void 0;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._wsEndpoint = wsEndpoint;
  }
  clearHistory() {
    this._history = [];
  }
  async post(prompt) {
<<<<<<< HEAD
    await this._append("user", prompt);
    let text = await asString(await this._post());
    if (text.startsWith("```json") && text.endsWith("```"))
      text = text.substring("```json".length, text.length - "```".length);
=======
    await this._append('user', prompt);
    let text = await asString(await this._post());
    if (text.startsWith('```json') && text.endsWith('```')) text = text.substring('```json'.length, text.length - '```'.length);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    for (let i = 0; i < 3; ++i) {
      try {
        return JSON.parse(text);
      } catch (e) {
<<<<<<< HEAD
        await this._append("user", String(e));
      }
    }
    throw new Error("Failed to parse response: " + text);
  }
  async _append(user, content) {
    this._history.push({ user, content });
  }
  async _connection() {
    if (!this._connectionPromise) {
      this._connectionPromise = import_transport.WebSocketTransport.connect(void 0, this._wsEndpoint).then((transport) => {
        return new Connection(transport, (method, params) => this._dispatchEvent(method, params), () => {
        });
=======
        await this._append('user', String(e));
      }
    }
    throw new Error('Failed to parse response: ' + text);
  }
  async _append(user, content) {
    this._history.push({
      user,
      content
    });
  }
  async _connection() {
    if (!this._connectionPromise) {
      this._connectionPromise = _transport.WebSocketTransport.connect(undefined, this._wsEndpoint).then(transport => {
        return new Connection(transport, (method, params) => this._dispatchEvent(method, params), () => {});
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      });
    }
    return this._connectionPromise;
  }
  _dispatchEvent(method, params) {
<<<<<<< HEAD
    if (method === "chatChunk") {
      const { chatId, chunk } = params;
      const chunkSink = this._chatSinks.get(chatId);
      chunkSink(chunk);
      if (!chunk)
        this._chatSinks.delete(chatId);
=======
    if (method === 'chatChunk') {
      const {
        chatId,
        chunk
      } = params;
      const chunkSink = this._chatSinks.get(chatId);
      chunkSink(chunk);
      if (!chunk) this._chatSinks.delete(chatId);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    }
  }
  async _post() {
    const connection = await this._connection();
<<<<<<< HEAD
    const result = await connection.send("chat", { history: this._history });
    const { chatId } = result;
    const { iterable, addChunk } = iterablePump();
=======
    const result = await connection.send('chat', {
      history: this._history
    });
    const {
      chatId
    } = result;
    const {
      iterable,
      addChunk
    } = iterablePump();
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._chatSinks.set(chatId, addChunk);
    return iterable;
  }
}
<<<<<<< HEAD
async function asString(stream) {
  let result = "";
  for await (const chunk of stream)
    result += chunk;
=======
exports.Chat = Chat;
async function asString(stream) {
  let result = '';
  for await (const chunk of stream) result += chunk;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  return result;
}
function iterablePump() {
  let controller;
<<<<<<< HEAD
  const stream = new ReadableStream({ start: (c) => controller = c });
  const iterable = async function* () {
    const reader = stream.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
=======
  const stream = new ReadableStream({
    start: c => controller = c
  });
  const iterable = async function* () {
    const reader = stream.getReader();
    while (true) {
      const {
        done,
        value
      } = await reader.read();
      if (done) break;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      yield value;
    }
  }();
  return {
    iterable,
<<<<<<< HEAD
    addChunk: (chunk) => {
      if (chunk)
        controller.enqueue(chunk);
      else
        controller.close();
=======
    addChunk: chunk => {
      if (chunk) controller.enqueue(chunk);else controller.close();
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    }
  };
}
class Connection {
  constructor(transport, onEvent, onClose) {
<<<<<<< HEAD
    this._lastId = 0;
    this._closed = false;
    this._pending = /* @__PURE__ */ new Map();
=======
    this._transport = void 0;
    this._lastId = 0;
    this._closed = false;
    this._pending = new Map();
    this._onEvent = void 0;
    this._onClose = void 0;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._transport = transport;
    this._onEvent = onEvent;
    this._onClose = onClose;
    this._transport.onmessage = this._dispatchMessage.bind(this);
    this._transport.onclose = this._close.bind(this);
  }
  send(method, params) {
    const id = this._lastId++;
<<<<<<< HEAD
    const message = { id, method, params };
    this._transport.send(message);
    return new Promise((resolve, reject) => {
      this._pending.set(id, { resolve, reject });
    });
  }
  _dispatchMessage(message) {
    if (message.id === void 0) {
=======
    const message = {
      id,
      method,
      params
    };
    this._transport.send(message);
    return new Promise((resolve, reject) => {
      this._pending.set(id, {
        resolve,
        reject
      });
    });
  }
  _dispatchMessage(message) {
    if (message.id === undefined) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      this._onEvent(message.method, message.params);
      return;
    }
    const callback = this._pending.get(message.id);
    this._pending.delete(message.id);
<<<<<<< HEAD
    if (!callback)
      return;
=======
    if (!callback) return;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    if (message.error) {
      callback.reject(new Error(message.error.message));
      return;
    }
    callback.resolve(message.result);
  }
  _close() {
    this._closed = true;
<<<<<<< HEAD
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    for (const { reject } of this._pending.values())
      reject(new Error("Connection closed"));
=======
    this._transport.onmessage = undefined;
    this._transport.onclose = undefined;
    for (const {
      reject
    } of this._pending.values()) reject(new Error('Connection closed'));
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._onClose();
  }
  isClosed() {
    return this._closed;
  }
  close() {
<<<<<<< HEAD
    if (!this._closed)
      this._transport.close();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Chat,
  asString
});
=======
    if (!this._closed) this._transport.close();
  }
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
