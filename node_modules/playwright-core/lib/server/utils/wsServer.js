"use strict";
<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var wsServer_exports = {};
__export(wsServer_exports, {
  WSServer: () => WSServer,
  perMessageDeflate: () => perMessageDeflate
});
module.exports = __toCommonJS(wsServer_exports);
var import_network = require("./network");
var import_utilsBundle = require("../../utilsBundle");
var import_debugLogger = require("./debugLogger");
let lastConnectionId = 0;
const kConnectionSymbol = Symbol("kConnection");
const perMessageDeflate = {
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.perMessageDeflate = exports.WSServer = void 0;
var _network = require("./network");
var _utilsBundle = require("../../utilsBundle");
var _debugLogger = require("./debugLogger");
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let lastConnectionId = 0;
const kConnectionSymbol = Symbol('kConnection');
const perMessageDeflate = exports.perMessageDeflate = {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  serverNoContextTakeover: true,
  zlibDeflateOptions: {
    level: 3
  },
  zlibInflateOptions: {
    chunkSize: 10 * 1024
  },
  threshold: 10 * 1024
};
class WSServer {
  constructor(delegate) {
<<<<<<< HEAD
    this._delegate = delegate;
  }
  async listen(port = 0, hostname, path) {
    import_debugLogger.debugLogger.log("server", `Server started at ${/* @__PURE__ */ new Date()}`);
    const server = (0, import_network.createHttpServer)((request, response) => {
      if (request.method === "GET" && request.url === "/json") {
        response.setHeader("Content-Type", "application/json");
=======
    this._wsServer = void 0;
    this.server = void 0;
    this._delegate = void 0;
    this._delegate = delegate;
  }
  async listen(port = 0, hostname, path) {
    _debugLogger.debugLogger.log('server', `Server started at ${new Date()}`);
    const server = (0, _network.createHttpServer)((request, response) => {
      if (request.method === 'GET' && request.url === '/json') {
        response.setHeader('Content-Type', 'application/json');
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        response.end(JSON.stringify({
          wsEndpointPath: path
        }));
        return;
      }
<<<<<<< HEAD
      response.end("Running");
    });
    server.on("error", (error) => import_debugLogger.debugLogger.log("server", String(error)));
=======
      response.end('Running');
    });
    server.on('error', error => _debugLogger.debugLogger.log('server', String(error)));
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this.server = server;
    const wsEndpoint = await new Promise((resolve, reject) => {
      server.listen(port, hostname, () => {
        const address = server.address();
        if (!address) {
<<<<<<< HEAD
          reject(new Error("Could not bind server socket"));
          return;
        }
        const wsEndpoint2 = typeof address === "string" ? `${address}${path}` : `ws://${hostname || "localhost"}:${address.port}${path}`;
        resolve(wsEndpoint2);
      }).on("error", reject);
    });
    import_debugLogger.debugLogger.log("server", "Listening at " + wsEndpoint);
    this._wsServer = new import_utilsBundle.wsServer({
      noServer: true,
      perMessageDeflate
    });
    if (this._delegate.onHeaders)
      this._wsServer.on("headers", (headers) => this._delegate.onHeaders(headers));
    server.on("upgrade", (request, socket, head) => {
      const pathname = new URL("http://localhost" + request.url).pathname;
      if (pathname !== path) {
        socket.write(`HTTP/${request.httpVersion} 400 Bad Request\r
\r
`);
        socket.destroy();
        return;
      }
      const upgradeResult = this._delegate.onUpgrade?.(request, socket);
=======
          reject(new Error('Could not bind server socket'));
          return;
        }
        const wsEndpoint = typeof address === 'string' ? `${address}${path}` : `ws://${hostname || 'localhost'}:${address.port}${path}`;
        resolve(wsEndpoint);
      }).on('error', reject);
    });
    _debugLogger.debugLogger.log('server', 'Listening at ' + wsEndpoint);
    this._wsServer = new _utilsBundle.wsServer({
      noServer: true,
      perMessageDeflate
    });
    if (this._delegate.onHeaders) this._wsServer.on('headers', headers => this._delegate.onHeaders(headers));
    server.on('upgrade', (request, socket, head) => {
      var _this$_delegate$onUpg, _this$_delegate, _this$_wsServer;
      const pathname = new URL('http://localhost' + request.url).pathname;
      if (pathname !== path) {
        socket.write(`HTTP/${request.httpVersion} 400 Bad Request\r\n\r\n`);
        socket.destroy();
        return;
      }
      const upgradeResult = (_this$_delegate$onUpg = (_this$_delegate = this._delegate).onUpgrade) === null || _this$_delegate$onUpg === void 0 ? void 0 : _this$_delegate$onUpg.call(_this$_delegate, request, socket);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (upgradeResult) {
        socket.write(upgradeResult.error);
        socket.destroy();
        return;
      }
<<<<<<< HEAD
      this._wsServer?.handleUpgrade(request, socket, head, (ws) => this._wsServer?.emit("connection", ws, request));
    });
    this._wsServer.on("connection", (ws, request) => {
      import_debugLogger.debugLogger.log("server", "Connected client ws.extension=" + ws.extensions);
      const url = new URL("http://localhost" + (request.url || ""));
      const id = String(++lastConnectionId);
      import_debugLogger.debugLogger.log("server", `[${id}] serving connection: ${request.url}`);
=======
      (_this$_wsServer = this._wsServer) === null || _this$_wsServer === void 0 || _this$_wsServer.handleUpgrade(request, socket, head, ws => {
        var _this$_wsServer2;
        return (_this$_wsServer2 = this._wsServer) === null || _this$_wsServer2 === void 0 ? void 0 : _this$_wsServer2.emit('connection', ws, request);
      });
    });
    this._wsServer.on('connection', (ws, request) => {
      _debugLogger.debugLogger.log('server', 'Connected client ws.extension=' + ws.extensions);
      const url = new URL('http://localhost' + (request.url || ''));
      const id = String(++lastConnectionId);
      _debugLogger.debugLogger.log('server', `[${id}] serving connection: ${request.url}`);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      const connection = this._delegate.onConnection(request, url, ws, id);
      ws[kConnectionSymbol] = connection;
    });
    return wsEndpoint;
  }
  async close() {
<<<<<<< HEAD
    const server = this._wsServer;
    if (!server)
      return;
    import_debugLogger.debugLogger.log("server", "closing websocket server");
    const waitForClose = new Promise((f) => server.close(f));
    await Promise.all(Array.from(server.clients).map(async (ws) => {
      const connection = ws[kConnectionSymbol];
      if (connection)
        await connection.close();
      try {
        ws.terminate();
      } catch (e) {
      }
    }));
    await waitForClose;
    import_debugLogger.debugLogger.log("server", "closing http server");
    if (this.server)
      await new Promise((f) => this.server.close(f));
    this._wsServer = void 0;
    this.server = void 0;
    import_debugLogger.debugLogger.log("server", "closed server");
    await this._delegate.onClose?.();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WSServer,
  perMessageDeflate
});
=======
    var _this$_delegate$onClo, _this$_delegate2;
    const server = this._wsServer;
    if (!server) return;
    _debugLogger.debugLogger.log('server', 'closing websocket server');
    const waitForClose = new Promise(f => server.close(f));
    // First disconnect all remaining clients.
    await Promise.all(Array.from(server.clients).map(async ws => {
      const connection = ws[kConnectionSymbol];
      if (connection) await connection.close();
      try {
        ws.terminate();
      } catch (e) {}
    }));
    await waitForClose;
    _debugLogger.debugLogger.log('server', 'closing http server');
    if (this.server) await new Promise(f => this.server.close(f));
    this._wsServer = undefined;
    this.server = undefined;
    _debugLogger.debugLogger.log('server', 'closed server');
    await ((_this$_delegate$onClo = (_this$_delegate2 = this._delegate).onClose) === null || _this$_delegate$onClo === void 0 ? void 0 : _this$_delegate$onClo.call(_this$_delegate2));
  }
}
exports.WSServer = WSServer;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
