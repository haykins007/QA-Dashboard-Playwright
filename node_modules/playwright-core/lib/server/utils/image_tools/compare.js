"use strict";
<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var compare_exports = {};
__export(compare_exports, {
  compare: () => compare
});
module.exports = __toCommonJS(compare_exports);
var import_colorUtils = require("./colorUtils");
var import_imageChannel = require("./imageChannel");
var import_stats = require("./stats");
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compare = compare;
var _colorUtils = require("./colorUtils");
var _imageChannel = require("./imageChannel");
var _stats = require("./stats");
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
const SSIM_WINDOW_RADIUS = 15;
const VARIANCE_WINDOW_RADIUS = 1;
function drawPixel(width, data, x, y, r, g, b) {
  const idx = (y * width + x) * 4;
  data[idx + 0] = r;
  data[idx + 1] = g;
  data[idx + 2] = b;
  data[idx + 3] = 255;
}
function compare(actual, expected, diff, width, height, options = {}) {
  const {
<<<<<<< HEAD
    maxColorDeltaE94 = 1
=======
    maxColorDeltaE94 = 1.0
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  } = options;
  const paddingSize = Math.max(VARIANCE_WINDOW_RADIUS, SSIM_WINDOW_RADIUS);
  const paddingColorEven = [255, 0, 255];
  const paddingColorOdd = [0, 255, 0];
<<<<<<< HEAD
  const [r1, g1, b1] = import_imageChannel.ImageChannel.intoRGB(width, height, expected, {
=======
  const [r1, g1, b1] = _imageChannel.ImageChannel.intoRGB(width, height, expected, {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    paddingSize,
    paddingColorEven,
    paddingColorOdd
  });
<<<<<<< HEAD
  const [r2, g2, b2] = import_imageChannel.ImageChannel.intoRGB(width, height, actual, {
=======
  const [r2, g2, b2] = _imageChannel.ImageChannel.intoRGB(width, height, actual, {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    paddingSize,
    paddingColorEven,
    paddingColorOdd
  });
<<<<<<< HEAD
  const noop = (x, y) => {
  };
  const drawRedPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 0, 0) : noop;
  const drawYellowPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 255, 0) : noop;
  const drawGrayPixel = diff ? (x, y) => {
    const gray = (0, import_colorUtils.rgb2gray)(r1.get(x, y), g1.get(x, y), b1.get(x, y));
    const value = (0, import_colorUtils.blendWithWhite)(gray, 0.1);
=======
  const noop = (x, y) => {};
  const drawRedPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 0, 0) : noop;
  const drawYellowPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 255, 0) : noop;
  const drawGrayPixel = diff ? (x, y) => {
    const gray = (0, _colorUtils.rgb2gray)(r1.get(x, y), g1.get(x, y), b1.get(x, y));
    const value = (0, _colorUtils.blendWithWhite)(gray, 0.1);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    drawPixel(width, diff, x - paddingSize, y - paddingSize, value, value, value);
  } : noop;
  let fastR, fastG, fastB;
  let diffCount = 0;
  for (let y = paddingSize; y < r1.height - paddingSize; ++y) {
    for (let x = paddingSize; x < r1.width - paddingSize; ++x) {
<<<<<<< HEAD
=======
      // Fast-path: equal pixels.
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (r1.get(x, y) === r2.get(x, y) && g1.get(x, y) === g2.get(x, y) && b1.get(x, y) === b2.get(x, y)) {
        drawGrayPixel(x, y);
        continue;
      }
<<<<<<< HEAD
      const delta = (0, import_colorUtils.colorDeltaE94)(
        [r1.get(x, y), g1.get(x, y), b1.get(x, y)],
        [r2.get(x, y), g2.get(x, y), b2.get(x, y)]
      );
=======

      // Compare pixel colors using the dE94 color difference formulae.
      // The dE94 is normalized so that the value of 1.0 is the "just-noticeable-difference".
      // Color difference below 1.0 is not noticeable to a human eye, so we can disregard it.
      // See https://en.wikipedia.org/wiki/Color_difference
      const delta = (0, _colorUtils.colorDeltaE94)([r1.get(x, y), g1.get(x, y), b1.get(x, y)], [r2.get(x, y), g2.get(x, y), b2.get(x, y)]);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (delta <= maxColorDeltaE94) {
        drawGrayPixel(x, y);
        continue;
      }
      if (!fastR || !fastG || !fastB) {
<<<<<<< HEAD
        fastR = new import_stats.FastStats(r1, r2);
        fastG = new import_stats.FastStats(g1, g2);
        fastB = new import_stats.FastStats(b1, b2);
=======
        fastR = new _stats.FastStats(r1, r2);
        fastG = new _stats.FastStats(g1, g2);
        fastB = new _stats.FastStats(b1, b2);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      }
      const [varX1, varY1] = r1.boundXY(x - VARIANCE_WINDOW_RADIUS, y - VARIANCE_WINDOW_RADIUS);
      const [varX2, varY2] = r1.boundXY(x + VARIANCE_WINDOW_RADIUS, y + VARIANCE_WINDOW_RADIUS);
      const var1 = fastR.varianceC1(varX1, varY1, varX2, varY2) + fastG.varianceC1(varX1, varY1, varX2, varY2) + fastB.varianceC1(varX1, varY1, varX2, varY2);
      const var2 = fastR.varianceC2(varX1, varY1, varX2, varY2) + fastG.varianceC2(varX1, varY1, varX2, varY2) + fastB.varianceC2(varX1, varY1, varX2, varY2);
<<<<<<< HEAD
=======
      // if this pixel is a part of a flood fill of a 3x3 square of either of the images, then it cannot be
      // anti-aliasing pixel so it must be a pixel difference.
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (var1 === 0 || var2 === 0) {
        drawRedPixel(x, y);
        ++diffCount;
        continue;
      }
      const [ssimX1, ssimY1] = r1.boundXY(x - SSIM_WINDOW_RADIUS, y - SSIM_WINDOW_RADIUS);
      const [ssimX2, ssimY2] = r1.boundXY(x + SSIM_WINDOW_RADIUS, y + SSIM_WINDOW_RADIUS);
<<<<<<< HEAD
      const ssimRGB = ((0, import_stats.ssim)(fastR, ssimX1, ssimY1, ssimX2, ssimY2) + (0, import_stats.ssim)(fastG, ssimX1, ssimY1, ssimX2, ssimY2) + (0, import_stats.ssim)(fastB, ssimX1, ssimY1, ssimX2, ssimY2)) / 3;
=======
      const ssimRGB = ((0, _stats.ssim)(fastR, ssimX1, ssimY1, ssimX2, ssimY2) + (0, _stats.ssim)(fastG, ssimX1, ssimY1, ssimX2, ssimY2) + (0, _stats.ssim)(fastB, ssimX1, ssimY1, ssimX2, ssimY2)) / 3.0;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      const isAntialiased = ssimRGB >= 0.99;
      if (isAntialiased) {
        drawYellowPixel(x, y);
      } else {
        drawRedPixel(x, y);
        ++diffCount;
      }
    }
  }
  return diffCount;
<<<<<<< HEAD
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  compare
});
=======
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
