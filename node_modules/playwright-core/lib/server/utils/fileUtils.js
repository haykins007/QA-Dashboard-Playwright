"use strict";
<<<<<<< HEAD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var fileUtils_exports = {};
__export(fileUtils_exports, {
  SerializedFS: () => SerializedFS,
  canAccessFile: () => canAccessFile,
  copyFileAndMakeWritable: () => copyFileAndMakeWritable,
  existsAsync: () => existsAsync,
  mkdirIfNeeded: () => mkdirIfNeeded,
  removeFolders: () => removeFolders,
  sanitizeForFilePath: () => sanitizeForFilePath,
  toPosixPath: () => toPosixPath
});
module.exports = __toCommonJS(fileUtils_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_manualPromise = require("../../utils/isomorphic/manualPromise");
var import_zipBundle = require("../../zipBundle");
const existsAsync = (path2) => new Promise((resolve) => import_fs.default.stat(path2, (err) => resolve(!err)));
async function mkdirIfNeeded(filePath) {
  await import_fs.default.promises.mkdir(import_path.default.dirname(filePath), { recursive: true }).catch(() => {
  });
}
async function removeFolders(dirs) {
  return await Promise.all(dirs.map(
    (dir) => import_fs.default.promises.rm(dir, { recursive: true, force: true, maxRetries: 10 }).catch((e) => e)
  ));
}
function canAccessFile(file) {
  if (!file)
    return false;
  try {
    import_fs.default.accessSync(file);
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SerializedFS = void 0;
exports.canAccessFile = canAccessFile;
exports.copyFileAndMakeWritable = copyFileAndMakeWritable;
exports.existsAsync = void 0;
exports.mkdirIfNeeded = mkdirIfNeeded;
exports.removeFolders = removeFolders;
exports.sanitizeForFilePath = sanitizeForFilePath;
exports.toPosixPath = toPosixPath;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _manualPromise = require("../../utils/isomorphic/manualPromise");
var _zipBundle = require("../../zipBundle");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const existsAsync = path => new Promise(resolve => _fs.default.stat(path, err => resolve(!err)));
exports.existsAsync = existsAsync;
async function mkdirIfNeeded(filePath) {
  // This will harmlessly throw on windows if the dirname is the root directory.
  await _fs.default.promises.mkdir(_path.default.dirname(filePath), {
    recursive: true
  }).catch(() => {});
}
async function removeFolders(dirs) {
  return await Promise.all(dirs.map(dir => _fs.default.promises.rm(dir, {
    recursive: true,
    force: true,
    maxRetries: 10
  }).catch(e => e)));
}
function canAccessFile(file) {
  if (!file) return false;
  try {
    _fs.default.accessSync(file);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    return true;
  } catch (e) {
    return false;
  }
}
async function copyFileAndMakeWritable(from, to) {
<<<<<<< HEAD
  await import_fs.default.promises.copyFile(from, to);
  await import_fs.default.promises.chmod(to, 436);
}
function sanitizeForFilePath(s) {
  return s.replace(/[\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, "-");
}
function toPosixPath(aPath) {
  return aPath.split(import_path.default.sep).join(import_path.default.posix.sep);
}
class SerializedFS {
  constructor() {
    this._buffers = /* @__PURE__ */ new Map();
    this._operations = [];
    this._operationsDone = new import_manualPromise.ManualPromise();
    this._operationsDone.resolve();
  }
  mkdir(dir) {
    this._appendOperation({ op: "mkdir", dir });
  }
  writeFile(file, content, skipIfExists) {
    this._buffers.delete(file);
    this._appendOperation({ op: "writeFile", file, content, skipIfExists });
  }
  appendFile(file, text, flush) {
    if (!this._buffers.has(file))
      this._buffers.set(file, []);
    this._buffers.get(file).push(text);
    if (flush)
      this._flushFile(file);
  }
  _flushFile(file) {
    const buffer = this._buffers.get(file);
    if (buffer === void 0)
      return;
    const content = buffer.join("");
    this._buffers.delete(file);
    this._appendOperation({ op: "appendFile", file, content });
  }
  copyFile(from, to) {
    this._flushFile(from);
    this._buffers.delete(to);
    this._appendOperation({ op: "copyFile", from, to });
  }
  async syncAndGetError() {
    for (const file of this._buffers.keys())
      this._flushFile(file);
=======
  await _fs.default.promises.copyFile(from, to);
  await _fs.default.promises.chmod(to, 0o664);
}
function sanitizeForFilePath(s) {
  return s.replace(/[\x00-\x2C\x2E-\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, '-');
}
function toPosixPath(aPath) {
  return aPath.split(_path.default.sep).join(_path.default.posix.sep);
}
class SerializedFS {
  constructor() {
    this._buffers = new Map();
    // Should never be accessed from within appendOperation.
    this._error = void 0;
    this._operations = [];
    this._operationsDone = void 0;
    this._operationsDone = new _manualPromise.ManualPromise();
    this._operationsDone.resolve(); // No operations scheduled yet.
  }
  mkdir(dir) {
    this._appendOperation({
      op: 'mkdir',
      dir
    });
  }
  writeFile(file, content, skipIfExists) {
    this._buffers.delete(file); // No need to flush the buffer since we'll overwrite anyway.
    this._appendOperation({
      op: 'writeFile',
      file,
      content,
      skipIfExists
    });
  }
  appendFile(file, text, flush) {
    if (!this._buffers.has(file)) this._buffers.set(file, []);
    this._buffers.get(file).push(text);
    if (flush) this._flushFile(file);
  }
  _flushFile(file) {
    const buffer = this._buffers.get(file);
    if (buffer === undefined) return;
    const content = buffer.join('');
    this._buffers.delete(file);
    this._appendOperation({
      op: 'appendFile',
      file,
      content
    });
  }
  copyFile(from, to) {
    this._flushFile(from);
    this._buffers.delete(to); // No need to flush the buffer since we'll overwrite anyway.
    this._appendOperation({
      op: 'copyFile',
      from,
      to
    });
  }
  async syncAndGetError() {
    for (const file of this._buffers.keys()) this._flushFile(file);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    await this._operationsDone;
    return this._error;
  }
  zip(entries, zipFileName) {
<<<<<<< HEAD
    for (const file of this._buffers.keys())
      this._flushFile(file);
    this._appendOperation({ op: "zip", entries, zipFileName });
  }
  // This method serializes all writes to the trace.
  _appendOperation(op) {
    const last = this._operations[this._operations.length - 1];
    if (last?.op === "appendFile" && op.op === "appendFile" && last.file === op.file) {
=======
    for (const file of this._buffers.keys()) this._flushFile(file);

    // Chain the export operation against write operations,
    // so that files do not change during the export.
    this._appendOperation({
      op: 'zip',
      entries,
      zipFileName
    });
  }

  // This method serializes all writes to the trace.
  _appendOperation(op) {
    const last = this._operations[this._operations.length - 1];
    if ((last === null || last === void 0 ? void 0 : last.op) === 'appendFile' && op.op === 'appendFile' && last.file === op.file) {
      // Merge pending appendFile operations for performance.
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      last.content += op.content;
      return;
    }
    this._operations.push(op);
<<<<<<< HEAD
    if (this._operationsDone.isDone())
      this._performOperations();
  }
  async _performOperations() {
    this._operationsDone = new import_manualPromise.ManualPromise();
    while (this._operations.length) {
      const op = this._operations.shift();
      if (this._error)
        continue;
=======
    if (this._operationsDone.isDone()) this._performOperations();
  }
  async _performOperations() {
    this._operationsDone = new _manualPromise.ManualPromise();
    while (this._operations.length) {
      const op = this._operations.shift();
      // Ignore all operations after the first error.
      if (this._error) continue;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      try {
        await this._performOperation(op);
      } catch (e) {
        this._error = e;
      }
    }
    this._operationsDone.resolve();
  }
  async _performOperation(op) {
    switch (op.op) {
<<<<<<< HEAD
      case "mkdir": {
        await import_fs.default.promises.mkdir(op.dir, { recursive: true });
        return;
      }
      case "writeFile": {
        if (op.skipIfExists)
          await import_fs.default.promises.writeFile(op.file, op.content, { flag: "wx" }).catch(() => {
          });
        else
          await import_fs.default.promises.writeFile(op.file, op.content);
        return;
      }
      case "copyFile": {
        await import_fs.default.promises.copyFile(op.from, op.to);
        return;
      }
      case "appendFile": {
        await import_fs.default.promises.appendFile(op.file, op.content);
        return;
      }
      case "zip": {
        const zipFile = new import_zipBundle.yazl.ZipFile();
        const result = new import_manualPromise.ManualPromise();
        zipFile.on("error", (error) => result.reject(error));
        for (const entry of op.entries)
          zipFile.addFile(entry.value, entry.name);
        zipFile.end();
        zipFile.outputStream.pipe(import_fs.default.createWriteStream(op.zipFileName)).on("close", () => result.resolve()).on("error", (error) => result.reject(error));
        await result;
        return;
      }
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SerializedFS,
  canAccessFile,
  copyFileAndMakeWritable,
  existsAsync,
  mkdirIfNeeded,
  removeFolders,
  sanitizeForFilePath,
  toPosixPath
});
=======
      case 'mkdir':
        {
          await _fs.default.promises.mkdir(op.dir, {
            recursive: true
          });
          return;
        }
      case 'writeFile':
        {
          // Note: 'wx' flag only writes when the file does not exist.
          // See https://nodejs.org/api/fs.html#file-system-flags.
          // This way tracing never have to write the same resource twice.
          if (op.skipIfExists) await _fs.default.promises.writeFile(op.file, op.content, {
            flag: 'wx'
          }).catch(() => {});else await _fs.default.promises.writeFile(op.file, op.content);
          return;
        }
      case 'copyFile':
        {
          await _fs.default.promises.copyFile(op.from, op.to);
          return;
        }
      case 'appendFile':
        {
          await _fs.default.promises.appendFile(op.file, op.content);
          return;
        }
      case 'zip':
        {
          const zipFile = new _zipBundle.yazl.ZipFile();
          const result = new _manualPromise.ManualPromise();
          zipFile.on('error', error => result.reject(error));
          for (const entry of op.entries) zipFile.addFile(entry.value, entry.name);
          zipFile.end();
          zipFile.outputStream.pipe(_fs.default.createWriteStream(op.zipFileName)).on('close', () => result.resolve()).on('error', error => result.reject(error));
          await result;
          return;
        }
    }
  }
}
exports.SerializedFS = SerializedFS;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
