"use strict";
<<<<<<< HEAD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bidiBrowser_exports = {};
__export(bidiBrowser_exports, {
  BidiBrowser: () => BidiBrowser,
  BidiBrowserContext: () => BidiBrowserContext,
  Network: () => Network
});
module.exports = __toCommonJS(bidiBrowser_exports);
var import_eventsHelper = require("../utils/eventsHelper");
var import_browser = require("../browser");
var import_browserContext = require("../browserContext");
var network = __toESM(require("../network"));
var import_bidiConnection = require("./bidiConnection");
var import_bidiNetworkManager = require("./bidiNetworkManager");
var import_bidiPage = require("./bidiPage");
var bidi = __toESM(require("./third_party/bidiProtocol"));
class BidiBrowser extends import_browser.Browser {
  constructor(parent, transport, options) {
    super(parent, options);
    this._contexts = /* @__PURE__ */ new Map();
    this._bidiPages = /* @__PURE__ */ new Map();
    this._connection = new import_bidiConnection.BidiConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._eventListeners = [
      import_eventsHelper.eventsHelper.addEventListener(this._browserSession, "browsingContext.contextCreated", this._onBrowsingContextCreated.bind(this)),
      import_eventsHelper.eventsHelper.addEventListener(this._browserSession, "script.realmDestroyed", this._onScriptRealmDestroyed.bind(this))
    ];
  }
  static async connect(parent, transport, options) {
    const browser = new BidiBrowser(parent, transport, options);
    if (options.__testHookOnConnectToBrowser)
      await options.__testHookOnConnectToBrowser();
    let proxy;
    if (options.proxy) {
      proxy = {
        proxyType: "manual"
      };
      const url = new URL(options.proxy.server);
      switch (url.protocol) {
        case "http:":
          proxy.httpProxy = url.host;
          break;
        case "https:":
          proxy.httpsProxy = url.host;
          break;
        case "socks4:":
          proxy.socksProxy = url.host;
          proxy.socksVersion = 4;
          break;
        case "socks5:":
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Network = exports.BidiBrowserContext = exports.BidiBrowser = void 0;
var _eventsHelper = require("../utils/eventsHelper");
var _browser = require("../browser");
var _browserContext = require("../browserContext");
var network = _interopRequireWildcard(require("../network"));
var _bidiConnection = require("./bidiConnection");
var _bidiNetworkManager = require("./bidiNetworkManager");
var _bidiPage = require("./bidiPage");
var bidi = _interopRequireWildcard(require("./third_party/bidiProtocol"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class BidiBrowser extends _browser.Browser {
  static async connect(parent, transport, options) {
    const browser = new BidiBrowser(parent, transport, options);
    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();
    let proxy;
    if (options.proxy) {
      proxy = {
        proxyType: 'manual'
      };
      const url = new URL(options.proxy.server); // Validate proxy server.
      switch (url.protocol) {
        case 'http:':
          proxy.httpProxy = url.host;
          break;
        case 'https:':
          proxy.httpsProxy = url.host;
          break;
        case 'socks4:':
          proxy.socksProxy = url.host;
          proxy.socksVersion = 4;
          break;
        case 'socks5:':
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
          proxy.socksProxy = url.host;
          proxy.socksVersion = 5;
          break;
        default:
<<<<<<< HEAD
          throw new Error("Invalid proxy server protocol: " + options.proxy.server);
      }
      if (options.proxy.bypass)
        proxy.noProxy = options.proxy.bypass.split(",");
    }
    browser._bidiSessionInfo = await browser._browserSession.send("session.new", {
=======
          throw new Error('Invalid proxy server protocol: ' + options.proxy.server);
      }
      if (options.proxy.bypass) proxy.noProxy = options.proxy.bypass.split(',');
      // TODO: support authentication.
    }
    browser._bidiSessionInfo = await browser._browserSession.send('session.new', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      capabilities: {
        alwaysMatch: {
          acceptInsecureCerts: false,
          proxy,
          unhandledPromptBehavior: {
            default: bidi.Session.UserPromptHandlerType.Ignore
          },
          webSocketUrl: true
        }
      }
    });
<<<<<<< HEAD
    await browser._browserSession.send("session.subscribe", {
      events: [
        "browsingContext",
        "network",
        "log",
        "script"
      ]
    });
    if (options.persistent) {
      const context = new BidiBrowserContext(browser, void 0, options.persistent);
      browser._defaultContext = context;
      await context._initialize();
=======
    await browser._browserSession.send('session.subscribe', {
      events: ['browsingContext', 'network', 'log', 'script']
    });
    if (options.persistent) {
      browser._defaultContext = new BidiBrowserContext(browser, undefined, options.persistent);
      await browser._defaultContext._initialize();
      // Create default page as we cannot get access to the existing one.
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      const page = await browser._defaultContext.doCreateNewPage();
      await page.waitForInitializedOrError();
    }
    return browser;
  }
<<<<<<< HEAD
=======
  constructor(parent, transport, options) {
    super(parent, options);
    this._connection = void 0;
    this._browserSession = void 0;
    this._bidiSessionInfo = void 0;
    this._contexts = new Map();
    this._bidiPages = new Map();
    this._eventListeners = void 0;
    this._connection = new _bidiConnection.BidiConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, 'browsingContext.contextCreated', this._onBrowsingContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'script.realmDestroyed', this._onScriptRealmDestroyed.bind(this))];
  }
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  _onDisconnect() {
    this._didClose();
  }
  async doCreateNewContext(options) {
<<<<<<< HEAD
    const { userContext } = await this._browserSession.send("browser.createUserContext", {});
=======
    const {
      userContext
    } = await this._browserSession.send('browser.createUserContext', {});
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    const context = new BidiBrowserContext(this, userContext, options);
    await context._initialize();
    this._contexts.set(userContext, context);
    return context;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._bidiSessionInfo.capabilities.browserVersion;
  }
  userAgent() {
    return this._bidiSessionInfo.capabilities.userAgent;
  }
  isConnected() {
    return !this._connection.isClosed();
  }
  _onBrowsingContextCreated(event) {
    if (event.parent) {
      const parentFrameId = event.parent;
<<<<<<< HEAD
      for (const page2 of this._bidiPages.values()) {
        const parentFrame = page2._page._frameManager.frame(parentFrameId);
        if (!parentFrame)
          continue;
        page2._session.addFrameBrowsingContext(event.context);
        page2._page._frameManager.frameAttached(event.context, parentFrameId);
        const frame = page2._page._frameManager.frame(event.context);
        if (frame)
          frame._url = event.url;
=======
      for (const page of this._bidiPages.values()) {
        const parentFrame = page._page._frameManager.frame(parentFrameId);
        if (!parentFrame) continue;
        page._session.addFrameBrowsingContext(event.context);
        page._page._frameManager.frameAttached(event.context, parentFrameId);
        const frame = page._page._frameManager.frame(event.context);
        if (frame) frame._url = event.url;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        return;
      }
      return;
    }
    let context = this._contexts.get(event.userContext);
<<<<<<< HEAD
    if (!context)
      context = this._defaultContext;
    if (!context)
      return;
    const session = this._connection.createMainFrameBrowsingContextSession(event.context);
    const opener = event.originalOpener && this._bidiPages.get(event.originalOpener);
    const page = new import_bidiPage.BidiPage(context, session, opener || null);
=======
    if (!context) context = this._defaultContext;
    if (!context) return;
    const session = this._connection.createMainFrameBrowsingContextSession(event.context);
    const opener = event.originalOpener && this._bidiPages.get(event.originalOpener);
    const page = new _bidiPage.BidiPage(context, session, opener || null);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    page._page.mainFrame()._url = event.url;
    this._bidiPages.set(event.context, page);
  }
  _onBrowsingContextDestroyed(event) {
    if (event.parent) {
      this._browserSession.removeFrameBrowsingContext(event.context);
      const parentFrameId = event.parent;
      for (const page of this._bidiPages.values()) {
        const parentFrame = page._page._frameManager.frame(parentFrameId);
<<<<<<< HEAD
        if (!parentFrame)
          continue;
=======
        if (!parentFrame) continue;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        page._page._frameManager.frameDetached(event.context);
        return;
      }
      return;
    }
    const bidiPage = this._bidiPages.get(event.context);
<<<<<<< HEAD
    if (!bidiPage)
      return;
=======
    if (!bidiPage) return;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    bidiPage.didClose();
    this._bidiPages.delete(event.context);
  }
  _onScriptRealmDestroyed(event) {
    for (const page of this._bidiPages.values()) {
<<<<<<< HEAD
      if (page._onRealmDestroyed(event))
        return;
    }
  }
}
class BidiBrowserContext extends import_browserContext.BrowserContext {
  constructor(browser, browserContextId, options) {
    super(browser, options, browserContextId);
    this._initScriptIds = [];
    this._authenticateProxyViaHeader();
  }
  _bidiPages() {
    return [...this._browser._bidiPages.values()].filter((bidiPage) => bidiPage._browserContext === this);
  }
  async _initialize() {
    const promises = [
      super._initialize(),
      this._installMainBinding()
    ];
    if (this._options.viewport) {
      promises.push(this._browser._browserSession.send("browsingContext.setViewport", {
        viewport: {
          width: this._options.viewport.width,
          height: this._options.viewport.height
        },
        devicePixelRatio: this._options.deviceScaleFactor || 1,
        userContexts: [this._userContextId()]
      }));
    }
    await Promise.all(promises);
  }
  // TODO: consider calling this only when bindings are added.
  async _installMainBinding() {
    const functionDeclaration = import_bidiPage.addMainBinding.toString();
    const args = [{
      type: "channel",
      value: {
        channel: import_bidiPage.kPlaywrightBindingChannel,
        ownership: bidi.Script.ResultOwnership.Root
      }
    }];
    await this._browser._browserSession.send("script.addPreloadScript", {
      functionDeclaration,
      arguments: args,
      userContexts: [this._userContextId()]
    });
  }
  possiblyUninitializedPages() {
    return this._bidiPages().map((bidiPage) => bidiPage._page);
  }
  async doCreateNewPage() {
    (0, import_browserContext.assertBrowserContextIsNotOwned)(this);
    const { context } = await this._browser._browserSession.send("browsingContext.create", {
=======
      if (page._onRealmDestroyed(event)) return;
    }
  }
}
exports.BidiBrowser = BidiBrowser;
class BidiBrowserContext extends _browserContext.BrowserContext {
  constructor(browser, browserContextId, options) {
    super(browser, options, browserContextId);
    this._authenticateProxyViaHeader();
  }
  _bidiPages() {
    return [...this._browser._bidiPages.values()].filter(bidiPage => bidiPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._bidiPages().map(bidiPage => bidiPage._page);
  }
  async doCreateNewPage() {
    (0, _browserContext.assertBrowserContextIsNotOwned)(this);
    const {
      context
    } = await this._browser._browserSession.send('browsingContext.create', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      type: bidi.BrowsingContext.CreateType.Window,
      userContext: this._browserContextId
    });
    return this._browser._bidiPages.get(context)._page;
  }
  async doGetCookies(urls) {
<<<<<<< HEAD
    const { cookies } = await this._browser._browserSession.send(
      "storage.getCookies",
      { partition: { type: "storageKey", userContext: this._browserContextId } }
    );
    return network.filterCookies(cookies.map((c) => {
      const copy = {
        name: c.name,
        value: (0, import_bidiNetworkManager.bidiBytesValueToString)(c.value),
=======
    const {
      cookies
    } = await this._browser._browserSession.send('storage.getCookies', {
      partition: {
        type: 'storageKey',
        userContext: this._browserContextId
      }
    });
    return network.filterCookies(cookies.map(c => {
      var _c$expiry;
      const copy = {
        name: c.name,
        value: (0, _bidiNetworkManager.bidiBytesValueToString)(c.value),
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        domain: c.domain,
        path: c.path,
        httpOnly: c.httpOnly,
        secure: c.secure,
<<<<<<< HEAD
        expires: c.expiry ?? -1,
        sameSite: c.sameSite ? fromBidiSameSite(c.sameSite) : "None"
=======
        expires: (_c$expiry = c.expiry) !== null && _c$expiry !== void 0 ? _c$expiry : -1,
        sameSite: c.sameSite ? fromBidiSameSite(c.sameSite) : 'None'
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      };
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    cookies = network.rewriteCookies(cookies);
<<<<<<< HEAD
    const promises = cookies.map((c) => {
      const cookie = {
        name: c.name,
        value: { type: "string", value: c.value },
=======
    const promises = cookies.map(c => {
      const cookie = {
        name: c.name,
        value: {
          type: 'string',
          value: c.value
        },
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        domain: c.domain,
        path: c.path,
        httpOnly: c.httpOnly,
        secure: c.secure,
        sameSite: c.sameSite && toBidiSameSite(c.sameSite),
<<<<<<< HEAD
        expiry: c.expires === -1 || c.expires === void 0 ? void 0 : Math.round(c.expires)
      };
      return this._browser._browserSession.send(
        "storage.setCookie",
        { cookie, partition: { type: "storageKey", userContext: this._browserContextId } }
      );
=======
        expiry: c.expires === -1 || c.expires === undefined ? undefined : Math.round(c.expires)
      };
      return this._browser._browserSession.send('storage.setCookie', {
        cookie,
        partition: {
          type: 'storageKey',
          userContext: this._browserContextId
        }
      });
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    });
    await Promise.all(promises);
  }
  async doClearCookies() {
<<<<<<< HEAD
    await this._browser._browserSession.send(
      "storage.deleteCookies",
      { partition: { type: "storageKey", userContext: this._browserContextId } }
    );
  }
  async doGrantPermissions(origin, permissions) {
  }
  async doClearPermissions() {
  }
  async setGeolocation(geolocation) {
  }
  async setExtraHTTPHeaders(headers) {
  }
  async setUserAgent(userAgent) {
  }
  async setOffline(offline) {
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page._delegate.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    const { script } = await this._browser._browserSession.send("script.addPreloadScript", {
      // TODO: remove function call from the source.
      functionDeclaration: `() => { return ${initScript.source} }`,
      userContexts: [this._browserContextId || "default"]
    });
    if (!initScript.internal)
      this._initScriptIds.push(script);
  }
  async doRemoveNonInternalInitScripts() {
    const promise = Promise.all(this._initScriptIds.map((script) => this._browser._browserSession.send("script.removePreloadScript", { script })));
    this._initScriptIds = [];
    await promise;
  }
  async doUpdateRequestInterception() {
  }
  onClosePersistent() {
  }
  async clearCache() {
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      await this._browser.close({ reason });
      return;
    }
    await this._browser._browserSession.send("browser.removeUserContext", {
=======
    await this._browser._browserSession.send('storage.deleteCookies', {
      partition: {
        type: 'storageKey',
        userContext: this._browserContextId
      }
    });
  }
  async doGrantPermissions(origin, permissions) {}
  async doClearPermissions() {}
  async setGeolocation(geolocation) {}
  async setExtraHTTPHeaders(headers) {}
  async setUserAgent(userAgent) {}
  async setOffline(offline) {}
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages()) await page._delegate.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    await Promise.all(this.pages().map(page => page._delegate.addInitScript(initScript)));
  }
  async doRemoveNonInternalInitScripts() {}
  async doUpdateRequestInterception() {}
  onClosePersistent() {}
  async clearCache() {}
  async doClose(reason) {
    if (!this._browserContextId) {
      // Closing persistent context should close the browser.
      await this._browser.close({
        reason
      });
      return;
    }
    await this._browser._browserSession.send('browser.removeUserContext', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      userContext: this._browserContextId
    });
    this._browser._contexts.delete(this._browserContextId);
  }
<<<<<<< HEAD
  async cancelDownload(uuid) {
  }
  _userContextId() {
    if (this._browserContextId)
      return this._browserContextId;
    return "default";
  }
}
function fromBidiSameSite(sameSite) {
  switch (sameSite) {
    case "strict":
      return "Strict";
    case "lax":
      return "Lax";
    case "none":
      return "None";
  }
  return "None";
}
function toBidiSameSite(sameSite) {
  switch (sameSite) {
    case "Strict":
      return bidi.Network.SameSite.Strict;
    case "Lax":
      return bidi.Network.SameSite.Lax;
    case "None":
=======
  async cancelDownload(uuid) {}
}
exports.BidiBrowserContext = BidiBrowserContext;
function fromBidiSameSite(sameSite) {
  switch (sameSite) {
    case 'strict':
      return 'Strict';
    case 'lax':
      return 'Lax';
    case 'none':
      return 'None';
  }
  return 'None';
}
function toBidiSameSite(sameSite) {
  switch (sameSite) {
    case 'Strict':
      return bidi.Network.SameSite.Strict;
    case 'Lax':
      return bidi.Network.SameSite.Lax;
    case 'None':
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      return bidi.Network.SameSite.None;
  }
  return bidi.Network.SameSite.None;
}
<<<<<<< HEAD
var Network;
((Network2) => {
  let SameSite;
  ((SameSite2) => {
    SameSite2["Strict"] = "strict";
    SameSite2["Lax"] = "lax";
    SameSite2["None"] = "none";
  })(SameSite = Network2.SameSite || (Network2.SameSite = {}));
})(Network || (Network = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BidiBrowser,
  BidiBrowserContext,
  Network
});
=======
let Network = exports.Network = void 0;
(function (_Network) {
  let SameSite = /*#__PURE__*/function (SameSite) {
    SameSite["Strict"] = "strict";
    SameSite["Lax"] = "lax";
    SameSite["None"] = "none";
    return SameSite;
  }({});
  _Network.SameSite = SameSite;
})(Network || (exports.Network = Network = {}));
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
