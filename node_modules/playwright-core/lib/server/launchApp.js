"use strict";
<<<<<<< HEAD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var launchApp_exports = {};
__export(launchApp_exports, {
  launchApp: () => launchApp,
  syncLocalStorageWithSettings: () => syncLocalStorageWithSettings
});
module.exports = __toCommonJS(launchApp_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_utils = require("../utils");
var import_instrumentation = require("./instrumentation");
var import_registry = require("./registry");
var import_registry2 = require("./registry");
async function launchApp(browserType, options) {
  const args = [...options.persistentContextOptions?.args ?? []];
  let channel = options.persistentContextOptions?.channel;
  if (browserType.name() === "chromium") {
    args.push(
      "--app=data:text/html,",
      `--window-size=${options.windowSize.width},${options.windowSize.height}`,
      ...options.windowPosition ? [`--window-position=${options.windowPosition.x},${options.windowPosition.y}`] : [],
      "--test-type="
    );
    if (!channel && !options.persistentContextOptions?.executablePath)
      channel = (0, import_registry.findChromiumChannel)(options.sdkLanguage);
  }
  const context = await browserType.launchPersistentContext((0, import_instrumentation.serverSideCallMetadata)(), "", {
    ignoreDefaultArgs: ["--enable-automation"],
    ...options?.persistentContextOptions,
    channel,
    noDefaultViewport: options.persistentContextOptions?.noDefaultViewport ?? true,
    acceptDownloads: options?.persistentContextOptions?.acceptDownloads ?? ((0, import_utils.isUnderTest)() ? "accept" : "internal-browser-default"),
    colorScheme: options?.persistentContextOptions?.colorScheme ?? "no-override",
    args
  });
  const [page] = context.pages();
  if (browserType.name() === "chromium" && process.platform === "darwin") {
    context.on("page", async (newPage) => {
      if (newPage.mainFrame().url() === "chrome://new-tab-page/") {
        await page.bringToFront();
        await newPage.close((0, import_instrumentation.serverSideCallMetadata)());
      }
    });
  }
  if (browserType.name() === "chromium")
    await installAppIcon(page);
  return { context, page };
}
async function installAppIcon(page) {
  const icon = await import_fs.default.promises.readFile(require.resolve("./chromium/appIcon.png"));
  const crPage = page._delegate;
  await crPage._mainFrameSession._client.send("Browser.setDockTile", {
    image: icon.toString("base64")
  });
}
async function syncLocalStorageWithSettings(page, appName) {
  if ((0, import_utils.isUnderTest)())
    return;
  const settingsFile = import_path.default.join(import_registry2.registryDirectory, ".settings", `${appName}.json`);
  await page.exposeBinding("_saveSerializedSettings", false, (_, settings2) => {
    import_fs.default.mkdirSync(import_path.default.dirname(settingsFile), { recursive: true });
    import_fs.default.writeFileSync(settingsFile, settings2);
  });
  const settings = await import_fs.default.promises.readFile(settingsFile, "utf-8").catch(() => "{}");
  await page.addInitScript(
    `(${String((settings2) => {
      if (location && location.protocol === "data:")
        return;
      if (window.top !== window)
        return;
      Object.entries(settings2).map(([k, v]) => localStorage[k] = v);
      window.saveSettings = () => {
        window._saveSerializedSettings(JSON.stringify({ ...localStorage }));
      };
    })})(${settings});
  `
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  launchApp,
  syncLocalStorageWithSettings
});
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.launchApp = launchApp;
exports.syncLocalStorageWithSettings = syncLocalStorageWithSettings;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _utils = require("../utils");
var _instrumentation = require("./instrumentation");
var _registry = require("./registry");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

async function launchApp(browserType, options) {
  var _options$persistentCo, _options$persistentCo2, _options$persistentCo3, _options$persistentCo4, _options$persistentCo5, _options$persistentCo6, _options$persistentCo7, _options$persistentCo8, _options$persistentCo9, _options$persistentCo10, _options$persistentCo11;
  const args = [...((_options$persistentCo = (_options$persistentCo2 = options.persistentContextOptions) === null || _options$persistentCo2 === void 0 ? void 0 : _options$persistentCo2.args) !== null && _options$persistentCo !== void 0 ? _options$persistentCo : [])];
  if (browserType.name() === 'chromium') {
    args.push('--app=data:text/html,', `--window-size=${options.windowSize.width},${options.windowSize.height}`, ...(options.windowPosition ? [`--window-position=${options.windowPosition.x},${options.windowPosition.y}`] : []), '--test-type=');
  }
  const context = await browserType.launchPersistentContext((0, _instrumentation.serverSideCallMetadata)(), '', {
    ignoreDefaultArgs: ['--enable-automation'],
    ...(options === null || options === void 0 ? void 0 : options.persistentContextOptions),
    channel: (_options$persistentCo3 = (_options$persistentCo4 = options.persistentContextOptions) === null || _options$persistentCo4 === void 0 ? void 0 : _options$persistentCo4.channel) !== null && _options$persistentCo3 !== void 0 ? _options$persistentCo3 : !((_options$persistentCo5 = options.persistentContextOptions) !== null && _options$persistentCo5 !== void 0 && _options$persistentCo5.executablePath) ? (0, _registry.findChromiumChannel)(options.sdkLanguage) : undefined,
    noDefaultViewport: (_options$persistentCo6 = (_options$persistentCo7 = options.persistentContextOptions) === null || _options$persistentCo7 === void 0 ? void 0 : _options$persistentCo7.noDefaultViewport) !== null && _options$persistentCo6 !== void 0 ? _options$persistentCo6 : true,
    acceptDownloads: (_options$persistentCo8 = options === null || options === void 0 || (_options$persistentCo9 = options.persistentContextOptions) === null || _options$persistentCo9 === void 0 ? void 0 : _options$persistentCo9.acceptDownloads) !== null && _options$persistentCo8 !== void 0 ? _options$persistentCo8 : (0, _utils.isUnderTest)() ? 'accept' : 'internal-browser-default',
    colorScheme: (_options$persistentCo10 = options === null || options === void 0 || (_options$persistentCo11 = options.persistentContextOptions) === null || _options$persistentCo11 === void 0 ? void 0 : _options$persistentCo11.colorScheme) !== null && _options$persistentCo10 !== void 0 ? _options$persistentCo10 : 'no-override',
    args
  });
  const [page] = context.pages();
  // Chromium on macOS opens a new tab when clicking on the dock icon.
  // See https://github.com/microsoft/playwright/issues/9434
  if (browserType.name() === 'chromium' && process.platform === 'darwin') {
    context.on('page', async newPage => {
      if (newPage.mainFrame().url() === 'chrome://new-tab-page/') {
        await page.bringToFront();
        await newPage.close((0, _instrumentation.serverSideCallMetadata)());
      }
    });
  }
  if (browserType.name() === 'chromium') await installAppIcon(page);
  return {
    context,
    page
  };
}
async function installAppIcon(page) {
  const icon = await _fs.default.promises.readFile(require.resolve('./chromium/appIcon.png'));
  const crPage = page._delegate;
  await crPage._mainFrameSession._client.send('Browser.setDockTile', {
    image: icon.toString('base64')
  });
}
async function syncLocalStorageWithSettings(page, appName) {
  if ((0, _utils.isUnderTest)()) return;
  const settingsFile = _path.default.join(_registry.registryDirectory, '.settings', `${appName}.json`);
  await page.exposeBinding('_saveSerializedSettings', false, (_, settings) => {
    _fs.default.mkdirSync(_path.default.dirname(settingsFile), {
      recursive: true
    });
    _fs.default.writeFileSync(settingsFile, settings);
  });
  const settings = await _fs.default.promises.readFile(settingsFile, 'utf-8').catch(() => '{}');
  await page.addInitScript(`(${String(settings => {
    // iframes w/ snapshots, etc.
    if (location && location.protocol === 'data:') return;
    if (window.top !== window) return;
    Object.entries(settings).map(([k, v]) => localStorage[k] = v);
    window.saveSettings = () => {
      window._saveSerializedSettings(JSON.stringify({
        ...localStorage
      }));
    };
  })})(${settings});
  `);
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
