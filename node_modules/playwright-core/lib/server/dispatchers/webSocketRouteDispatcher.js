"use strict";
<<<<<<< HEAD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var webSocketRouteDispatcher_exports = {};
__export(webSocketRouteDispatcher_exports, {
  WebSocketRouteDispatcher: () => WebSocketRouteDispatcher
});
module.exports = __toCommonJS(webSocketRouteDispatcher_exports);
var import_page = require("../page");
var import_dispatcher = require("./dispatcher");
var import_pageDispatcher = require("./pageDispatcher");
var webSocketMockSource = __toESM(require("../../generated/webSocketMockSource"));
var import_crypto = require("../utils/crypto");
var import_urlMatch = require("../../utils/isomorphic/urlMatch");
var import_eventsHelper = require("../utils/eventsHelper");
class WebSocketRouteDispatcher extends import_dispatcher.Dispatcher {
  constructor(scope, id, url, frame) {
    super(scope, { guid: "webSocketRoute@" + (0, import_crypto.createGuid)() }, "WebSocketRoute", { url });
    this._type_WebSocketRoute = true;
    this._id = id;
    this._frame = frame;
    this._eventListeners.push(
      // When the frame navigates or detaches, there will be no more communication
      // from the mock websocket, so pretend like it was closed.
      import_eventsHelper.eventsHelper.addEventListener(frame._page, import_page.Page.Events.InternalFrameNavigatedToNewDocument, (frame2) => {
        if (frame2 === this._frame)
          this._executionContextGone();
      }),
      import_eventsHelper.eventsHelper.addEventListener(frame._page, import_page.Page.Events.FrameDetached, (frame2) => {
        if (frame2 === this._frame)
          this._executionContextGone();
      }),
      import_eventsHelper.eventsHelper.addEventListener(frame._page, import_page.Page.Events.Close, () => this._executionContextGone()),
      import_eventsHelper.eventsHelper.addEventListener(frame._page, import_page.Page.Events.Crash, () => this._executionContextGone())
    );
    WebSocketRouteDispatcher._idToDispatcher.set(this._id, this);
    scope._dispatchEvent("webSocketRoute", { webSocketRoute: this });
  }
  static {
    this._idToDispatcher = /* @__PURE__ */ new Map();
  }
  static async installIfNeeded(target) {
    const kBindingName = "__pwWebSocketBinding";
    const context = target instanceof import_page.Page ? target.context() : target;
    if (!context.hasBinding(kBindingName)) {
      await context.exposeBinding(kBindingName, false, (source, payload) => {
        if (payload.type === "onCreate") {
          const contextDispatcher = (0, import_dispatcher.existingDispatcher)(context);
          const pageDispatcher = contextDispatcher ? import_pageDispatcher.PageDispatcher.fromNullable(contextDispatcher, source.page) : void 0;
          let scope;
          if (pageDispatcher && matchesPattern(pageDispatcher, context._options.baseURL, payload.url))
            scope = pageDispatcher;
          else if (contextDispatcher && matchesPattern(contextDispatcher, context._options.baseURL, payload.url))
            scope = contextDispatcher;
          if (scope) {
            new WebSocketRouteDispatcher(scope, payload.id, payload.url, source.frame);
          } else {
            const request = { id: payload.id, type: "passthrough" };
            source.frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request)})`).catch(() => {
            });
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebSocketRouteDispatcher = void 0;
var _page = require("../page");
var _dispatcher = require("./dispatcher");
var _pageDispatcher = require("./pageDispatcher");
var webSocketMockSource = _interopRequireWildcard(require("../../generated/webSocketMockSource"));
var _crypto = require("../utils/crypto");
var _urlMatch = require("../../utils/isomorphic/urlMatch");
var _eventsHelper = require("../utils/eventsHelper");
var _WebSocketRouteDispatcher;
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class WebSocketRouteDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, id, url, frame) {
    super(scope, {
      guid: 'webSocketRoute@' + (0, _crypto.createGuid)()
    }, 'WebSocketRoute', {
      url
    });
    this._type_WebSocketRoute = true;
    this._id = void 0;
    this._frame = void 0;
    this._id = id;
    this._frame = frame;
    this._eventListeners.push(
    // When the frame navigates or detaches, there will be no more communication
    // from the mock websocket, so pretend like it was closed.
    _eventsHelper.eventsHelper.addEventListener(frame._page, _page.Page.Events.InternalFrameNavigatedToNewDocument, frame => {
      if (frame === this._frame) this._executionContextGone();
    }), _eventsHelper.eventsHelper.addEventListener(frame._page, _page.Page.Events.FrameDetached, frame => {
      if (frame === this._frame) this._executionContextGone();
    }), _eventsHelper.eventsHelper.addEventListener(frame._page, _page.Page.Events.Close, () => this._executionContextGone()), _eventsHelper.eventsHelper.addEventListener(frame._page, _page.Page.Events.Crash, () => this._executionContextGone()));
    WebSocketRouteDispatcher._idToDispatcher.set(this._id, this);
    scope._dispatchEvent('webSocketRoute', {
      webSocketRoute: this
    });
  }
  static async installIfNeeded(target) {
    const kBindingName = '__pwWebSocketBinding';
    const context = target instanceof _page.Page ? target.context() : target;
    if (!context.hasBinding(kBindingName)) {
      await context.exposeBinding(kBindingName, false, (source, payload) => {
        if (payload.type === 'onCreate') {
          const contextDispatcher = (0, _dispatcher.existingDispatcher)(context);
          const pageDispatcher = contextDispatcher ? _pageDispatcher.PageDispatcher.fromNullable(contextDispatcher, source.page) : undefined;
          let scope;
          if (pageDispatcher && matchesPattern(pageDispatcher, context._options.baseURL, payload.url)) scope = pageDispatcher;else if (contextDispatcher && matchesPattern(contextDispatcher, context._options.baseURL, payload.url)) scope = contextDispatcher;
          if (scope) {
            new WebSocketRouteDispatcher(scope, payload.id, payload.url, source.frame);
          } else {
            const request = {
              id: payload.id,
              type: 'passthrough'
            };
            source.frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request)})`).catch(() => {});
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
          }
          return;
        }
        const dispatcher = WebSocketRouteDispatcher._idToDispatcher.get(payload.id);
<<<<<<< HEAD
        if (payload.type === "onMessageFromPage")
          dispatcher?._dispatchEvent("messageFromPage", { message: payload.data.data, isBase64: payload.data.isBase64 });
        if (payload.type === "onMessageFromServer")
          dispatcher?._dispatchEvent("messageFromServer", { message: payload.data.data, isBase64: payload.data.isBase64 });
        if (payload.type === "onClosePage")
          dispatcher?._dispatchEvent("closePage", { code: payload.code, reason: payload.reason, wasClean: payload.wasClean });
        if (payload.type === "onCloseServer")
          dispatcher?._dispatchEvent("closeServer", { code: payload.code, reason: payload.reason, wasClean: payload.wasClean });
      });
    }
    const kInitScriptName = "webSocketMockSource";
    if (!target.initScripts.find((s) => s.name === kInitScriptName)) {
=======
        if (payload.type === 'onMessageFromPage') dispatcher === null || dispatcher === void 0 || dispatcher._dispatchEvent('messageFromPage', {
          message: payload.data.data,
          isBase64: payload.data.isBase64
        });
        if (payload.type === 'onMessageFromServer') dispatcher === null || dispatcher === void 0 || dispatcher._dispatchEvent('messageFromServer', {
          message: payload.data.data,
          isBase64: payload.data.isBase64
        });
        if (payload.type === 'onClosePage') dispatcher === null || dispatcher === void 0 || dispatcher._dispatchEvent('closePage', {
          code: payload.code,
          reason: payload.reason,
          wasClean: payload.wasClean
        });
        if (payload.type === 'onCloseServer') dispatcher === null || dispatcher === void 0 || dispatcher._dispatchEvent('closeServer', {
          code: payload.code,
          reason: payload.reason,
          wasClean: payload.wasClean
        });
      });
    }
    const kInitScriptName = 'webSocketMockSource';
    if (!target.initScripts.find(s => s.name === kInitScriptName)) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      await target.addInitScript(`
        (() => {
          const module = {};
          ${webSocketMockSource.source}
          (module.exports.inject())(globalThis);
        })();
      `, kInitScriptName);
    }
  }
  async connect(params) {
<<<<<<< HEAD
    await this._evaluateAPIRequest({ id: this._id, type: "connect" });
  }
  async ensureOpened(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "ensureOpened" });
  }
  async sendToPage(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "sendToPage", data: { data: params.message, isBase64: params.isBase64 } });
  }
  async sendToServer(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "sendToServer", data: { data: params.message, isBase64: params.isBase64 } });
  }
  async closePage(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "closePage", code: params.code, reason: params.reason, wasClean: params.wasClean });
  }
  async closeServer(params) {
    await this._evaluateAPIRequest({ id: this._id, type: "closeServer", code: params.code, reason: params.reason, wasClean: params.wasClean });
  }
  async _evaluateAPIRequest(request) {
    await this._frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request)})`).catch(() => {
    });
=======
    await this._evaluateAPIRequest({
      id: this._id,
      type: 'connect'
    });
  }
  async ensureOpened(params) {
    await this._evaluateAPIRequest({
      id: this._id,
      type: 'ensureOpened'
    });
  }
  async sendToPage(params) {
    await this._evaluateAPIRequest({
      id: this._id,
      type: 'sendToPage',
      data: {
        data: params.message,
        isBase64: params.isBase64
      }
    });
  }
  async sendToServer(params) {
    await this._evaluateAPIRequest({
      id: this._id,
      type: 'sendToServer',
      data: {
        data: params.message,
        isBase64: params.isBase64
      }
    });
  }
  async closePage(params) {
    await this._evaluateAPIRequest({
      id: this._id,
      type: 'closePage',
      code: params.code,
      reason: params.reason,
      wasClean: params.wasClean
    });
  }
  async closeServer(params) {
    await this._evaluateAPIRequest({
      id: this._id,
      type: 'closeServer',
      code: params.code,
      reason: params.reason,
      wasClean: params.wasClean
    });
  }
  async _evaluateAPIRequest(request) {
    await this._frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request)})`).catch(() => {});
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  _onDispose() {
    WebSocketRouteDispatcher._idToDispatcher.delete(this._id);
  }
  _executionContextGone() {
<<<<<<< HEAD
    if (!this._disposed) {
      this._dispatchEvent("closePage", { wasClean: true });
      this._dispatchEvent("closeServer", { wasClean: true });
    }
  }
}
function matchesPattern(dispatcher, baseURL, url) {
  for (const pattern of dispatcher._webSocketInterceptionPatterns || []) {
    const urlMatch = pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob;
    if ((0, import_urlMatch.urlMatches)(baseURL, url, urlMatch, true))
      return true;
  }
  return false;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WebSocketRouteDispatcher
});
=======
    // We could enter here after being disposed upon page closure:
    // - first from the recursive dispose inintiated by PageDispatcher;
    // - then from our own page.on('close') listener.
    if (!this._disposed) {
      this._dispatchEvent('closePage', {
        wasClean: true
      });
      this._dispatchEvent('closeServer', {
        wasClean: true
      });
    }
  }
}
exports.WebSocketRouteDispatcher = WebSocketRouteDispatcher;
_WebSocketRouteDispatcher = WebSocketRouteDispatcher;
WebSocketRouteDispatcher._idToDispatcher = new Map();
function matchesPattern(dispatcher, baseURL, url) {
  for (const pattern of dispatcher._webSocketInterceptionPatterns || []) {
    const urlMatch = pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob;
    if ((0, _urlMatch.urlMatches)(baseURL, url, urlMatch)) return true;
  }
  return false;
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
