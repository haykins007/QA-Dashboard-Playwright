"use strict";
<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var networkDispatchers_exports = {};
__export(networkDispatchers_exports, {
  APIRequestContextDispatcher: () => APIRequestContextDispatcher,
  RequestDispatcher: () => RequestDispatcher,
  ResponseDispatcher: () => ResponseDispatcher,
  RouteDispatcher: () => RouteDispatcher,
  WebSocketDispatcher: () => WebSocketDispatcher
});
module.exports = __toCommonJS(networkDispatchers_exports);
var import_network = require("../network");
var import_dispatcher = require("./dispatcher");
var import_frameDispatcher = require("./frameDispatcher");
var import_pageDispatcher = require("./pageDispatcher");
var import_tracingDispatcher = require("./tracingDispatcher");
class RequestDispatcher extends import_dispatcher.Dispatcher {
  static from(scope, request) {
    const result = (0, import_dispatcher.existingDispatcher)(request);
    return result || new RequestDispatcher(scope, request);
  }
  static fromNullable(scope, request) {
    return request ? RequestDispatcher.from(scope, request) : void 0;
  }
  constructor(scope, request) {
    const postData = request.postDataBuffer();
    const frame = request.frame();
    const page = request.frame()?._page;
    const pageDispatcher = page ? (0, import_dispatcher.existingDispatcher)(page) : null;
    const frameDispatcher = frame ? import_frameDispatcher.FrameDispatcher.from(scope, frame) : null;
    super(pageDispatcher || frameDispatcher || scope, request, "Request", {
      frame: import_frameDispatcher.FrameDispatcher.fromNullable(scope, request.frame()),
      serviceWorker: import_pageDispatcher.WorkerDispatcher.fromNullable(scope, request.serviceWorker()),
      url: request.url(),
      resourceType: request.resourceType(),
      method: request.method(),
      postData: postData === null ? void 0 : postData,
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebSocketDispatcher = exports.RouteDispatcher = exports.ResponseDispatcher = exports.RequestDispatcher = exports.APIRequestContextDispatcher = void 0;
var _network = require("../network");
var _dispatcher = require("./dispatcher");
var _frameDispatcher = require("./frameDispatcher");
var _pageDispatcher = require("./pageDispatcher");
var _tracingDispatcher = require("./tracingDispatcher");
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class RequestDispatcher extends _dispatcher.Dispatcher {
  static from(scope, request) {
    const result = (0, _dispatcher.existingDispatcher)(request);
    return result || new RequestDispatcher(scope, request);
  }
  static fromNullable(scope, request) {
    return request ? RequestDispatcher.from(scope, request) : undefined;
  }
  constructor(scope, request) {
    var _request$frame;
    const postData = request.postDataBuffer();
    // Always try to attach request to the page, if not, frame.
    const frame = request.frame();
    const page = (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page;
    const pageDispatcher = page ? (0, _dispatcher.existingDispatcher)(page) : null;
    const frameDispatcher = frame ? _frameDispatcher.FrameDispatcher.from(scope, frame) : null;
    super(pageDispatcher || frameDispatcher || scope, request, 'Request', {
      frame: _frameDispatcher.FrameDispatcher.fromNullable(scope, request.frame()),
      serviceWorker: _pageDispatcher.WorkerDispatcher.fromNullable(scope, request.serviceWorker()),
      url: request.url(),
      resourceType: request.resourceType(),
      method: request.method(),
      postData: postData === null ? undefined : postData,
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      headers: request.headers(),
      isNavigationRequest: request.isNavigationRequest(),
      redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
    });
<<<<<<< HEAD
=======
    this._type_Request = void 0;
    this._browserContextDispatcher = void 0;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._type_Request = true;
    this._browserContextDispatcher = scope;
  }
  async rawRequestHeaders(params) {
<<<<<<< HEAD
    return { headers: await this._object.rawRequestHeaders() };
  }
  async response() {
    return { response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await this._object.response()) };
  }
}
class ResponseDispatcher extends import_dispatcher.Dispatcher {
  constructor(scope, response) {
    super(scope, response, "Response", {
=======
    return {
      headers: await this._object.rawRequestHeaders()
    };
  }
  async response() {
    return {
      response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await this._object.response())
    };
  }
}
exports.RequestDispatcher = RequestDispatcher;
class ResponseDispatcher extends _dispatcher.Dispatcher {
  static from(scope, response) {
    const result = (0, _dispatcher.existingDispatcher)(response);
    const requestDispatcher = RequestDispatcher.from(scope, response.request());
    return result || new ResponseDispatcher(requestDispatcher, response);
  }
  static fromNullable(scope, response) {
    return response ? ResponseDispatcher.from(scope, response) : undefined;
  }
  constructor(scope, response) {
    super(scope, response, 'Response', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      // TODO: responses in popups can point to non-reported requests.
      request: scope,
      url: response.url(),
      status: response.status(),
      statusText: response.statusText(),
      headers: response.headers(),
      timing: response.timing(),
      fromServiceWorker: response.fromServiceWorker()
    });
    this._type_Response = true;
  }
<<<<<<< HEAD
  static from(scope, response) {
    const result = (0, import_dispatcher.existingDispatcher)(response);
    const requestDispatcher = RequestDispatcher.from(scope, response.request());
    return result || new ResponseDispatcher(requestDispatcher, response);
  }
  static fromNullable(scope, response) {
    return response ? ResponseDispatcher.from(scope, response) : void 0;
  }
  async body() {
    return { binary: await this._object.body() };
  }
  async securityDetails() {
    return { value: await this._object.securityDetails() || void 0 };
  }
  async serverAddr() {
    return { value: await this._object.serverAddr() || void 0 };
  }
  async rawResponseHeaders(params) {
    return { headers: await this._object.rawResponseHeaders() };
  }
  async sizes(params) {
    return { sizes: await this._object.sizes() };
  }
}
class RouteDispatcher extends import_dispatcher.Dispatcher {
  constructor(scope, route) {
    super(scope, route, "Route", {
=======
  async body() {
    return {
      binary: await this._object.body()
    };
  }
  async securityDetails() {
    return {
      value: (await this._object.securityDetails()) || undefined
    };
  }
  async serverAddr() {
    return {
      value: (await this._object.serverAddr()) || undefined
    };
  }
  async rawResponseHeaders(params) {
    return {
      headers: await this._object.rawResponseHeaders()
    };
  }
  async sizes(params) {
    return {
      sizes: await this._object.sizes()
    };
  }
}
exports.ResponseDispatcher = ResponseDispatcher;
class RouteDispatcher extends _dispatcher.Dispatcher {
  static from(scope, route) {
    const result = (0, _dispatcher.existingDispatcher)(route);
    return result || new RouteDispatcher(scope, route);
  }
  constructor(scope, route) {
    super(scope, route, 'Route', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      // Context route can point to a non-reported request, so we send the request in the initializer.
      request: scope
    });
    this._type_Route = true;
  }
<<<<<<< HEAD
  static from(scope, route) {
    const result = (0, import_dispatcher.existingDispatcher)(route);
    return result || new RouteDispatcher(scope, route);
  }
=======
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  async continue(params, metadata) {
    await this._object.continue({
      url: params.url,
      method: params.method,
      headers: params.headers,
      postData: params.postData,
      isFallback: params.isFallback
    });
  }
  async fulfill(params, metadata) {
    await this._object.fulfill(params);
  }
  async abort(params, metadata) {
<<<<<<< HEAD
    await this._object.abort(params.errorCode || "failed");
=======
    await this._object.abort(params.errorCode || 'failed');
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  async redirectNavigationRequest(params) {
    await this._object.redirectNavigationRequest(params.url);
  }
}
<<<<<<< HEAD
class WebSocketDispatcher extends import_dispatcher.Dispatcher {
  constructor(scope, webSocket) {
    super(scope, webSocket, "WebSocket", {
=======
exports.RouteDispatcher = RouteDispatcher;
class WebSocketDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, webSocket) {
    super(scope, webSocket, 'WebSocket', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      url: webSocket.url()
    });
    this._type_EventTarget = true;
    this._type_WebSocket = true;
<<<<<<< HEAD
    this.addObjectListener(import_network.WebSocket.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
    this.addObjectListener(import_network.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
    this.addObjectListener(import_network.WebSocket.Events.SocketError, (error) => this._dispatchEvent("socketError", { error }));
    this.addObjectListener(import_network.WebSocket.Events.Close, () => this._dispatchEvent("close", {}));
  }
}
class APIRequestContextDispatcher extends import_dispatcher.Dispatcher {
  constructor(parentScope, request) {
    const tracing = import_tracingDispatcher.TracingDispatcher.from(parentScope, request.tracing());
    super(parentScope, request, "APIRequestContext", {
=======
    this.addObjectListener(_network.WebSocket.Events.FrameSent, event => this._dispatchEvent('frameSent', event));
    this.addObjectListener(_network.WebSocket.Events.FrameReceived, event => this._dispatchEvent('frameReceived', event));
    this.addObjectListener(_network.WebSocket.Events.SocketError, error => this._dispatchEvent('socketError', {
      error
    }));
    this.addObjectListener(_network.WebSocket.Events.Close, () => this._dispatchEvent('close', {}));
  }
}
exports.WebSocketDispatcher = WebSocketDispatcher;
class APIRequestContextDispatcher extends _dispatcher.Dispatcher {
  static from(scope, request) {
    const result = (0, _dispatcher.existingDispatcher)(request);
    return result || new APIRequestContextDispatcher(scope, request);
  }
  static fromNullable(scope, request) {
    return request ? APIRequestContextDispatcher.from(scope, request) : undefined;
  }
  constructor(parentScope, request) {
    // We will reparent these to the context below.
    const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, request.tracing());
    super(parentScope, request, 'APIRequestContext', {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      tracing
    });
    this._type_APIRequestContext = true;
    this.adopt(tracing);
  }
<<<<<<< HEAD
  static from(scope, request) {
    const result = (0, import_dispatcher.existingDispatcher)(request);
    return result || new APIRequestContextDispatcher(scope, request);
  }
  static fromNullable(scope, request) {
    return request ? APIRequestContextDispatcher.from(scope, request) : void 0;
  }
=======
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  async storageState(params) {
    return this._object.storageState(params.indexedDB);
  }
  async dispose(params, metadata) {
    metadata.potentiallyClosesScope = true;
    await this._object.dispose(params);
    this._dispose();
  }
  async fetch(params, metadata) {
    const fetchResponse = await this._object.fetch(params, metadata);
    return {
      response: {
        url: fetchResponse.url,
        status: fetchResponse.status,
        statusText: fetchResponse.statusText,
        headers: fetchResponse.headers,
        fetchUid: fetchResponse.fetchUid
      }
    };
  }
  async fetchResponseBody(params) {
<<<<<<< HEAD
    return { binary: this._object.fetchResponses.get(params.fetchUid) };
  }
  async fetchLog(params) {
    const log = this._object.fetchLog.get(params.fetchUid) || [];
    return { log };
=======
    return {
      binary: this._object.fetchResponses.get(params.fetchUid)
    };
  }
  async fetchLog(params) {
    const log = this._object.fetchLog.get(params.fetchUid) || [];
    return {
      log
    };
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  async disposeAPIResponse(params) {
    this._object.disposeResponse(params.fetchUid);
  }
}
<<<<<<< HEAD
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APIRequestContextDispatcher,
  RequestDispatcher,
  ResponseDispatcher,
  RouteDispatcher,
  WebSocketDispatcher
});
=======
exports.APIRequestContextDispatcher = APIRequestContextDispatcher;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
