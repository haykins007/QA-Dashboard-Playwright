"use strict";
<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cssTokenizer_exports = {};
__export(cssTokenizer_exports, {
  AtKeywordToken: () => AtKeywordToken,
  BadStringToken: () => BadStringToken,
  BadURLToken: () => BadURLToken,
  CDCToken: () => CDCToken,
  CDOToken: () => CDOToken,
  CSSParserToken: () => CSSParserToken,
  CloseCurlyToken: () => CloseCurlyToken,
  CloseParenToken: () => CloseParenToken,
  CloseSquareToken: () => CloseSquareToken,
  ColonToken: () => ColonToken,
  ColumnToken: () => ColumnToken,
  CommaToken: () => CommaToken,
  DashMatchToken: () => DashMatchToken,
  DelimToken: () => DelimToken,
  DimensionToken: () => DimensionToken,
  EOFToken: () => EOFToken,
  FunctionToken: () => FunctionToken,
  GroupingToken: () => GroupingToken,
  HashToken: () => HashToken,
  IdentToken: () => IdentToken,
  IncludeMatchToken: () => IncludeMatchToken,
  InvalidCharacterError: () => InvalidCharacterError,
  NumberToken: () => NumberToken,
  OpenCurlyToken: () => OpenCurlyToken,
  OpenParenToken: () => OpenParenToken,
  OpenSquareToken: () => OpenSquareToken,
  PercentageToken: () => PercentageToken,
  PrefixMatchToken: () => PrefixMatchToken,
  SemicolonToken: () => SemicolonToken,
  StringToken: () => StringToken,
  StringValuedToken: () => StringValuedToken,
  SubstringMatchToken: () => SubstringMatchToken,
  SuffixMatchToken: () => SuffixMatchToken,
  URLToken: () => URLToken,
  WhitespaceToken: () => WhitespaceToken,
  tokenize: () => tokenize
});
module.exports = __toCommonJS(cssTokenizer_exports);
const between = function(num, first, last) {
  return num >= first && num <= last;
};
function digit(code) {
  return between(code, 48, 57);
}
function hexdigit(code) {
  return digit(code) || between(code, 65, 70) || between(code, 97, 102);
}
function uppercaseletter(code) {
  return between(code, 65, 90);
}
function lowercaseletter(code) {
  return between(code, 97, 122);
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WhitespaceToken = exports.URLToken = exports.SuffixMatchToken = exports.SubstringMatchToken = exports.StringValuedToken = exports.StringToken = exports.SemicolonToken = exports.PrefixMatchToken = exports.PercentageToken = exports.OpenSquareToken = exports.OpenParenToken = exports.OpenCurlyToken = exports.NumberToken = exports.InvalidCharacterError = exports.IncludeMatchToken = exports.IdentToken = exports.HashToken = exports.GroupingToken = exports.FunctionToken = exports.EOFToken = exports.DimensionToken = exports.DelimToken = exports.DashMatchToken = exports.CommaToken = exports.ColumnToken = exports.ColonToken = exports.CloseSquareToken = exports.CloseParenToken = exports.CloseCurlyToken = exports.CSSParserToken = exports.CDOToken = exports.CDCToken = exports.BadURLToken = exports.BadStringToken = exports.AtKeywordToken = void 0;
exports.tokenize = tokenize;
/* eslint-disable notice/notice */

/*
 * The code in this file is licensed under the CC0 license.
 * http://creativecommons.org/publicdomain/zero/1.0/
 * It is free to use for any purpose. No attribution, permission, or reproduction of this license is required.
 */

// Original at https://github.com/tabatkins/parse-css
// Changes:
//   - JS is replaced with TS.
//   - Universal Module Definition wrapper is removed.
//   - Everything not related to tokenizing - below the first exports block - is removed.

const between = function (num, first, last) {
  return num >= first && num <= last;
};
function digit(code) {
  return between(code, 0x30, 0x39);
}
function hexdigit(code) {
  return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66);
}
function uppercaseletter(code) {
  return between(code, 0x41, 0x5a);
}
function lowercaseletter(code) {
  return between(code, 0x61, 0x7a);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
}
function letter(code) {
  return uppercaseletter(code) || lowercaseletter(code);
}
function nonascii(code) {
<<<<<<< HEAD
  return code >= 128;
}
function namestartchar(code) {
  return letter(code) || nonascii(code) || code === 95;
}
function namechar(code) {
  return namestartchar(code) || digit(code) || code === 45;
}
function nonprintable(code) {
  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;
}
function newline(code) {
  return code === 10;
}
function whitespace(code) {
  return newline(code) || code === 9 || code === 32;
}
const maximumallowedcodepoint = 1114111;
class InvalidCharacterError extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidCharacterError";
  }
}
function preprocess(str) {
  const codepoints = [];
  for (let i = 0; i < str.length; i++) {
    let code = str.charCodeAt(i);
    if (code === 13 && str.charCodeAt(i + 1) === 10) {
      code = 10;
      i++;
    }
    if (code === 13 || code === 12)
      code = 10;
    if (code === 0)
      code = 65533;
    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
      const lead = code - 55296;
      const trail = str.charCodeAt(i + 1) - 56320;
=======
  return code >= 0x80;
}
function namestartchar(code) {
  return letter(code) || nonascii(code) || code === 0x5f;
}
function namechar(code) {
  return namestartchar(code) || digit(code) || code === 0x2d;
}
function nonprintable(code) {
  return between(code, 0, 8) || code === 0xb || between(code, 0xe, 0x1f) || code === 0x7f;
}
function newline(code) {
  return code === 0xa;
}
function whitespace(code) {
  return newline(code) || code === 9 || code === 0x20;
}
const maximumallowedcodepoint = 0x10ffff;
class InvalidCharacterError extends Error {
  constructor(message) {
    super(message);
    this.name = 'InvalidCharacterError';
  }
}
exports.InvalidCharacterError = InvalidCharacterError;
function preprocess(str) {
  // Turn a string into an array of code points,
  // following the preprocessing cleanup rules.
  const codepoints = [];
  for (let i = 0; i < str.length; i++) {
    let code = str.charCodeAt(i);
    if (code === 0xd && str.charCodeAt(i + 1) === 0xa) {
      code = 0xa;
      i++;
    }
    if (code === 0xd || code === 0xc) code = 0xa;
    if (code === 0x0) code = 0xfffd;
    if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {
      // Decode a surrogate pair into an astral codepoint.
      const lead = code - 0xd800;
      const trail = str.charCodeAt(i + 1) - 0xdc00;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
      i++;
    }
    codepoints.push(code);
  }
  return codepoints;
}
function stringFromCode(code) {
<<<<<<< HEAD
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= Math.pow(2, 16);
  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;
  const trail = code % Math.pow(2, 10) + 56320;
=======
  if (code <= 0xffff) return String.fromCharCode(code);
  // Otherwise, encode astral char as surrogate pair.
  code -= Math.pow(2, 16);
  const lead = Math.floor(code / Math.pow(2, 10)) + 0xd800;
  const trail = code % Math.pow(2, 10) + 0xdc00;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  return String.fromCharCode(lead) + String.fromCharCode(trail);
}
function tokenize(str1) {
  const str = preprocess(str1);
  let i = -1;
  const tokens = [];
  let code;
<<<<<<< HEAD
  let line = 0;
  let column = 0;
  let lastLineLength = 0;
  const incrLineno = function() {
=======

  // Line number information.
  let line = 0;
  let column = 0;
  // The only use of lastLineLength is in reconsume().
  let lastLineLength = 0;
  const incrLineno = function () {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    line += 1;
    lastLineLength = column;
    column = 0;
  };
<<<<<<< HEAD
  const locStart = { line, column };
  const codepoint = function(i2) {
    if (i2 >= str.length)
      return -1;
    return str[i2];
  };
  const next = function(num) {
    if (num === void 0)
      num = 1;
    if (num > 3)
      throw "Spec Error: no more than three codepoints of lookahead.";
    return codepoint(i + num);
  };
  const consume = function(num) {
    if (num === void 0)
      num = 1;
    i += num;
    code = codepoint(i);
    if (newline(code))
      incrLineno();
    else
      column += num;
    return true;
  };
  const reconsume = function() {
=======
  const locStart = {
    line: line,
    column: column
  };
  const codepoint = function (i) {
    if (i >= str.length) return -1;
    return str[i];
  };
  const next = function (num) {
    if (num === undefined) num = 1;
    if (num > 3) throw 'Spec Error: no more than three codepoints of lookahead.';
    return codepoint(i + num);
  };
  const consume = function (num) {
    if (num === undefined) num = 1;
    i += num;
    code = codepoint(i);
    if (newline(code)) incrLineno();else column += num;
    // console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
    return true;
  };
  const reconsume = function () {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    i -= 1;
    if (newline(code)) {
      line -= 1;
      column = lastLineLength;
    } else {
      column -= 1;
    }
    locStart.line = line;
    locStart.column = column;
    return true;
  };
<<<<<<< HEAD
  const eof = function(codepoint2) {
    if (codepoint2 === void 0)
      codepoint2 = code;
    return codepoint2 === -1;
  };
  const donothing = function() {
  };
  const parseerror = function() {
  };
  const consumeAToken = function() {
    consumeComments();
    consume();
    if (whitespace(code)) {
      while (whitespace(next()))
        consume();
      return new WhitespaceToken();
    } else if (code === 34) {
      return consumeAStringToken();
    } else if (code === 35) {
      if (namechar(next()) || areAValidEscape(next(1), next(2))) {
        const token = new HashToken("");
        if (wouldStartAnIdentifier(next(1), next(2), next(3)))
          token.type = "id";
=======
  const eof = function (codepoint) {
    if (codepoint === undefined) codepoint = code;
    return codepoint === -1;
  };
  const donothing = function () {};
  const parseerror = function () {
    // Language bindings don't like writing to stdout!
    // console.log('Parse error at index ' + i + ', processing codepoint 0x' + code.toString(16) + '.'); return true;
  };
  const consumeAToken = function () {
    consumeComments();
    consume();
    if (whitespace(code)) {
      while (whitespace(next())) consume();
      return new WhitespaceToken();
    } else if (code === 0x22) {
      return consumeAStringToken();
    } else if (code === 0x23) {
      if (namechar(next()) || areAValidEscape(next(1), next(2))) {
        const token = new HashToken('');
        if (wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = 'id';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        token.value = consumeAName();
        return token;
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 36) {
      if (next() === 61) {
=======
    } else if (code === 0x24) {
      if (next() === 0x3d) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume();
        return new SuffixMatchToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 39) {
      return consumeAStringToken();
    } else if (code === 40) {
      return new OpenParenToken();
    } else if (code === 41) {
      return new CloseParenToken();
    } else if (code === 42) {
      if (next() === 61) {
=======
    } else if (code === 0x27) {
      return consumeAStringToken();
    } else if (code === 0x28) {
      return new OpenParenToken();
    } else if (code === 0x29) {
      return new CloseParenToken();
    } else if (code === 0x2a) {
      if (next() === 0x3d) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume();
        return new SubstringMatchToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 43) {
=======
    } else if (code === 0x2b) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 44) {
      return new CommaToken();
    } else if (code === 45) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else if (next(1) === 45 && next(2) === 62) {
=======
    } else if (code === 0x2c) {
      return new CommaToken();
    } else if (code === 0x2d) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else if (next(1) === 0x2d && next(2) === 0x3e) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume(2);
        return new CDCToken();
      } else if (startsWithAnIdentifier()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 46) {
=======
    } else if (code === 0x2e) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 58) {
      return new ColonToken();
    } else if (code === 59) {
      return new SemicolonToken();
    } else if (code === 60) {
      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {
=======
    } else if (code === 0x3a) {
      return new ColonToken();
    } else if (code === 0x3b) {
      return new SemicolonToken();
    } else if (code === 0x3c) {
      if (next(1) === 0x21 && next(2) === 0x2d && next(3) === 0x2d) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume(3);
        return new CDOToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 64) {
      if (wouldStartAnIdentifier(next(1), next(2), next(3)))
        return new AtKeywordToken(consumeAName());
      else
        return new DelimToken(code);
    } else if (code === 91) {
      return new OpenSquareToken();
    } else if (code === 92) {
=======
    } else if (code === 0x40) {
      if (wouldStartAnIdentifier(next(1), next(2), next(3))) return new AtKeywordToken(consumeAName());else return new DelimToken(code);
    } else if (code === 0x5b) {
      return new OpenSquareToken();
    } else if (code === 0x5c) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (startsWithAValidEscape()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        parseerror();
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 93) {
      return new CloseSquareToken();
    } else if (code === 94) {
      if (next() === 61) {
=======
    } else if (code === 0x5d) {
      return new CloseSquareToken();
    } else if (code === 0x5e) {
      if (next() === 0x3d) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume();
        return new PrefixMatchToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 123) {
      return new OpenCurlyToken();
    } else if (code === 124) {
      if (next() === 61) {
        consume();
        return new DashMatchToken();
      } else if (next() === 124) {
=======
    } else if (code === 0x7b) {
      return new OpenCurlyToken();
    } else if (code === 0x7c) {
      if (next() === 0x3d) {
        consume();
        return new DashMatchToken();
      } else if (next() === 0x7c) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume();
        return new ColumnToken();
      } else {
        return new DelimToken(code);
      }
<<<<<<< HEAD
    } else if (code === 125) {
      return new CloseCurlyToken();
    } else if (code === 126) {
      if (next() === 61) {
=======
    } else if (code === 0x7d) {
      return new CloseCurlyToken();
    } else if (code === 0x7e) {
      if (next() === 0x3d) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        consume();
        return new IncludeMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (digit(code)) {
      reconsume();
      return consumeANumericToken();
    } else if (namestartchar(code)) {
      reconsume();
      return consumeAnIdentlikeToken();
    } else if (eof()) {
      return new EOFToken();
    } else {
      return new DelimToken(code);
    }
  };
<<<<<<< HEAD
  const consumeComments = function() {
    while (next(1) === 47 && next(2) === 42) {
      consume(2);
      while (true) {
        consume();
        if (code === 42 && next() === 47) {
=======
  const consumeComments = function () {
    while (next(1) === 0x2f && next(2) === 0x2a) {
      consume(2);
      while (true) {
        consume();
        if (code === 0x2a && next() === 0x2f) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
          consume();
          break;
        } else if (eof()) {
          parseerror();
          return;
        }
      }
    }
  };
<<<<<<< HEAD
  const consumeANumericToken = function() {
=======
  const consumeANumericToken = function () {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    const num = consumeANumber();
    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
      const token = new DimensionToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      token.unit = consumeAName();
      return token;
<<<<<<< HEAD
    } else if (next() === 37) {
=======
    } else if (next() === 0x25) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      consume();
      const token = new PercentageToken();
      token.value = num.value;
      token.repr = num.repr;
      return token;
    } else {
      const token = new NumberToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      return token;
    }
  };
<<<<<<< HEAD
  const consumeAnIdentlikeToken = function() {
    const str2 = consumeAName();
    if (str2.toLowerCase() === "url" && next() === 40) {
      consume();
      while (whitespace(next(1)) && whitespace(next(2)))
        consume();
      if (next() === 34 || next() === 39)
        return new FunctionToken(str2);
      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))
        return new FunctionToken(str2);
      else
        return consumeAURLToken();
    } else if (next() === 40) {
      consume();
      return new FunctionToken(str2);
    } else {
      return new IdentToken(str2);
    }
  };
  const consumeAStringToken = function(endingCodePoint) {
    if (endingCodePoint === void 0)
      endingCodePoint = code;
    let string = "";
=======
  const consumeAnIdentlikeToken = function () {
    const str = consumeAName();
    if (str.toLowerCase() === 'url' && next() === 0x28) {
      consume();
      while (whitespace(next(1)) && whitespace(next(2))) consume();
      if (next() === 0x22 || next() === 0x27) return new FunctionToken(str);else if (whitespace(next()) && (next(2) === 0x22 || next(2) === 0x27)) return new FunctionToken(str);else return consumeAURLToken();
    } else if (next() === 0x28) {
      consume();
      return new FunctionToken(str);
    } else {
      return new IdentToken(str);
    }
  };
  const consumeAStringToken = function (endingCodePoint) {
    if (endingCodePoint === undefined) endingCodePoint = code;
    let string = '';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    while (consume()) {
      if (code === endingCodePoint || eof()) {
        return new StringToken(string);
      } else if (newline(code)) {
        parseerror();
        reconsume();
        return new BadStringToken();
<<<<<<< HEAD
      } else if (code === 92) {
        if (eof(next()))
          donothing();
        else if (newline(next()))
          consume();
        else
          string += stringFromCode(consumeEscape());
=======
      } else if (code === 0x5c) {
        if (eof(next())) donothing();else if (newline(next())) consume();else string += stringFromCode(consumeEscape());
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      } else {
        string += stringFromCode(code);
      }
    }
<<<<<<< HEAD
    throw new Error("Internal error");
  };
  const consumeAURLToken = function() {
    const token = new URLToken("");
    while (whitespace(next()))
      consume();
    if (eof(next()))
      return token;
    while (consume()) {
      if (code === 41 || eof()) {
        return token;
      } else if (whitespace(code)) {
        while (whitespace(next()))
          consume();
        if (next() === 41 || eof(next())) {
=======
    throw new Error('Internal error');
  };
  const consumeAURLToken = function () {
    const token = new URLToken('');
    while (whitespace(next())) consume();
    if (eof(next())) return token;
    while (consume()) {
      if (code === 0x29 || eof()) {
        return token;
      } else if (whitespace(code)) {
        while (whitespace(next())) consume();
        if (next() === 0x29 || eof(next())) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
          consume();
          return token;
        } else {
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
<<<<<<< HEAD
      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {
        parseerror();
        consumeTheRemnantsOfABadURL();
        return new BadURLToken();
      } else if (code === 92) {
=======
      } else if (code === 0x22 || code === 0x27 || code === 0x28 || nonprintable(code)) {
        parseerror();
        consumeTheRemnantsOfABadURL();
        return new BadURLToken();
      } else if (code === 0x5c) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        if (startsWithAValidEscape()) {
          token.value += stringFromCode(consumeEscape());
        } else {
          parseerror();
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else {
        token.value += stringFromCode(code);
      }
    }
<<<<<<< HEAD
    throw new Error("Internal error");
  };
  const consumeEscape = function() {
    consume();
    if (hexdigit(code)) {
=======
    throw new Error('Internal error');
  };
  const consumeEscape = function () {
    // Assume the current character is the \
    // and the next code point is not a newline.
    consume();
    if (hexdigit(code)) {
      // Consume 1-6 hex digits
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      const digits = [code];
      for (let total = 0; total < 5; total++) {
        if (hexdigit(next())) {
          consume();
          digits.push(code);
        } else {
          break;
        }
      }
<<<<<<< HEAD
      if (whitespace(next()))
        consume();
      let value = parseInt(digits.map(function(x) {
        return String.fromCharCode(x);
      }).join(""), 16);
      if (value > maximumallowedcodepoint)
        value = 65533;
      return value;
    } else if (eof()) {
      return 65533;
=======
      if (whitespace(next())) consume();
      let value = parseInt(digits.map(function (x) {
        return String.fromCharCode(x);
      }).join(''), 16);
      if (value > maximumallowedcodepoint) value = 0xfffd;
      return value;
    } else if (eof()) {
      return 0xfffd;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    } else {
      return code;
    }
  };
<<<<<<< HEAD
  const areAValidEscape = function(c1, c2) {
    if (c1 !== 92)
      return false;
    if (newline(c2))
      return false;
    return true;
  };
  const startsWithAValidEscape = function() {
    return areAValidEscape(code, next());
  };
  const wouldStartAnIdentifier = function(c1, c2, c3) {
    if (c1 === 45)
      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);
    else if (namestartchar(c1))
      return true;
    else if (c1 === 92)
      return areAValidEscape(c1, c2);
    else
      return false;
  };
  const startsWithAnIdentifier = function() {
    return wouldStartAnIdentifier(code, next(1), next(2));
  };
  const wouldStartANumber = function(c1, c2, c3) {
    if (c1 === 43 || c1 === 45) {
      if (digit(c2))
        return true;
      if (c2 === 46 && digit(c3))
        return true;
      return false;
    } else if (c1 === 46) {
      if (digit(c2))
        return true;
=======
  const areAValidEscape = function (c1, c2) {
    if (c1 !== 0x5c) return false;
    if (newline(c2)) return false;
    return true;
  };
  const startsWithAValidEscape = function () {
    return areAValidEscape(code, next());
  };
  const wouldStartAnIdentifier = function (c1, c2, c3) {
    if (c1 === 0x2d) return namestartchar(c2) || c2 === 0x2d || areAValidEscape(c2, c3);else if (namestartchar(c1)) return true;else if (c1 === 0x5c) return areAValidEscape(c1, c2);else return false;
  };
  const startsWithAnIdentifier = function () {
    return wouldStartAnIdentifier(code, next(1), next(2));
  };
  const wouldStartANumber = function (c1, c2, c3) {
    if (c1 === 0x2b || c1 === 0x2d) {
      if (digit(c2)) return true;
      if (c2 === 0x2e && digit(c3)) return true;
      return false;
    } else if (c1 === 0x2e) {
      if (digit(c2)) return true;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      return false;
    } else if (digit(c1)) {
      return true;
    } else {
      return false;
    }
  };
<<<<<<< HEAD
  const startsWithANumber = function() {
    return wouldStartANumber(code, next(1), next(2));
  };
  const consumeAName = function() {
    let result = "";
=======
  const startsWithANumber = function () {
    return wouldStartANumber(code, next(1), next(2));
  };
  const consumeAName = function () {
    let result = '';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    while (consume()) {
      if (namechar(code)) {
        result += stringFromCode(code);
      } else if (startsWithAValidEscape()) {
        result += stringFromCode(consumeEscape());
      } else {
        reconsume();
        return result;
      }
    }
<<<<<<< HEAD
    throw new Error("Internal parse error");
  };
  const consumeANumber = function() {
    let repr = "";
    let type = "integer";
    if (next() === 43 || next() === 45) {
=======
    throw new Error('Internal parse error');
  };
  const consumeANumber = function () {
    let repr = '';
    let type = 'integer';
    if (next() === 0x2b || next() === 0x2d) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      consume();
      repr += stringFromCode(code);
    }
    while (digit(next())) {
      consume();
      repr += stringFromCode(code);
    }
<<<<<<< HEAD
    if (next(1) === 46 && digit(next(2))) {
=======
    if (next(1) === 0x2e && digit(next(2))) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
<<<<<<< HEAD
      type = "number";
=======
      type = 'number';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
<<<<<<< HEAD
    const c1 = next(1), c2 = next(2), c3 = next(3);
    if ((c1 === 69 || c1 === 101) && digit(c2)) {
=======
    const c1 = next(1),
      c2 = next(2),
      c3 = next(3);
    if ((c1 === 0x45 || c1 === 0x65) && digit(c2)) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
<<<<<<< HEAD
      type = "number";
=======
      type = 'number';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
<<<<<<< HEAD
    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {
=======
    } else if ((c1 === 0x45 || c1 === 0x65) && (c2 === 0x2b || c2 === 0x2d) && digit(c3)) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
<<<<<<< HEAD
      type = "number";
=======
      type = 'number';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    const value = convertAStringToANumber(repr);
<<<<<<< HEAD
    return { type, value, repr };
  };
  const convertAStringToANumber = function(string) {
    return +string;
  };
  const consumeTheRemnantsOfABadURL = function() {
    while (consume()) {
      if (code === 41 || eof()) {
=======
    return {
      type: type,
      value: value,
      repr: repr
    };
  };
  const convertAStringToANumber = function (string) {
    // CSS's number rules are identical to JS, afaik.
    return +string;
  };
  const consumeTheRemnantsOfABadURL = function () {
    while (consume()) {
      if (code === 0x29 || eof()) {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        return;
      } else if (startsWithAValidEscape()) {
        consumeEscape();
        donothing();
      } else {
        donothing();
      }
    }
  };
  let iterationCount = 0;
  while (!eof(next())) {
    tokens.push(consumeAToken());
    iterationCount++;
<<<<<<< HEAD
    if (iterationCount > str.length * 2)
      throw new Error("I'm infinite-looping!");
=======
    if (iterationCount > str.length * 2) throw new Error("I'm infinite-looping!");
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  return tokens;
}
class CSSParserToken {
  constructor() {
<<<<<<< HEAD
    this.tokenType = "";
  }
  toJSON() {
    return { token: this.tokenType };
=======
    this.tokenType = '';
    this.value = void 0;
  }
  toJSON() {
    return {
      token: this.tokenType
    };
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toString() {
    return this.tokenType;
  }
  toSource() {
<<<<<<< HEAD
    return "" + this;
  }
}
class BadStringToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "BADSTRING";
  }
}
class BadURLToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "BADURL";
  }
}
class WhitespaceToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "WHITESPACE";
  }
  toString() {
    return "WS";
  }
  toSource() {
    return " ";
  }
}
class CDOToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "CDO";
  }
  toSource() {
    return "<!--";
  }
}
class CDCToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "CDC";
  }
  toSource() {
    return "-->";
  }
}
class ColonToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = ":";
  }
}
class SemicolonToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = ";";
  }
}
class CommaToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = ",";
  }
}
class GroupingToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.value = "";
    this.mirror = "";
  }
}
class OpenCurlyToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = "{";
    this.value = "{";
    this.mirror = "}";
  }
}
class CloseCurlyToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = "}";
    this.value = "}";
    this.mirror = "{";
  }
}
class OpenSquareToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = "[";
    this.value = "[";
    this.mirror = "]";
  }
}
class CloseSquareToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = "]";
    this.value = "]";
    this.mirror = "[";
  }
}
class OpenParenToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = "(";
    this.value = "(";
    this.mirror = ")";
  }
}
class CloseParenToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = ")";
    this.value = ")";
    this.mirror = "(";
  }
}
class IncludeMatchToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "~=";
  }
}
class DashMatchToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "|=";
  }
}
class PrefixMatchToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "^=";
  }
}
class SuffixMatchToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "$=";
  }
}
class SubstringMatchToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "*=";
  }
}
class ColumnToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "||";
  }
}
class EOFToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.tokenType = "EOF";
  }
  toSource() {
    return "";
  }
}
class DelimToken extends CSSParserToken {
  constructor(code) {
    super();
    this.tokenType = "DELIM";
    this.value = "";
    this.value = stringFromCode(code);
  }
  toString() {
    return "DELIM(" + this.value + ")";
=======
    return '' + this;
  }
}
exports.CSSParserToken = CSSParserToken;
class BadStringToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = 'BADSTRING';
  }
}
exports.BadStringToken = BadStringToken;
class BadURLToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = 'BADURL';
  }
}
exports.BadURLToken = BadURLToken;
class WhitespaceToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = 'WHITESPACE';
  }
  toString() {
    return 'WS';
  }
  toSource() {
    return ' ';
  }
}
exports.WhitespaceToken = WhitespaceToken;
class CDOToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = 'CDO';
  }
  toSource() {
    return '<!--';
  }
}
exports.CDOToken = CDOToken;
class CDCToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = 'CDC';
  }
  toSource() {
    return '-->';
  }
}
exports.CDCToken = CDCToken;
class ColonToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = ':';
  }
}
exports.ColonToken = ColonToken;
class SemicolonToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = ';';
  }
}
exports.SemicolonToken = SemicolonToken;
class CommaToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = ',';
  }
}
exports.CommaToken = CommaToken;
class GroupingToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.value = '';
    this.mirror = '';
  }
}
exports.GroupingToken = GroupingToken;
class OpenCurlyToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = '{';
    this.value = '{';
    this.mirror = '}';
  }
}
exports.OpenCurlyToken = OpenCurlyToken;
class CloseCurlyToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = '}';
    this.value = '}';
    this.mirror = '{';
  }
}
exports.CloseCurlyToken = CloseCurlyToken;
class OpenSquareToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = '[';
    this.value = '[';
    this.mirror = ']';
  }
}
exports.OpenSquareToken = OpenSquareToken;
class CloseSquareToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = ']';
    this.value = ']';
    this.mirror = '[';
  }
}
exports.CloseSquareToken = CloseSquareToken;
class OpenParenToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = '(';
    this.value = '(';
    this.mirror = ')';
  }
}
exports.OpenParenToken = OpenParenToken;
class CloseParenToken extends GroupingToken {
  constructor() {
    super();
    this.tokenType = ')';
    this.value = ')';
    this.mirror = '(';
  }
}
exports.CloseParenToken = CloseParenToken;
class IncludeMatchToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = '~=';
  }
}
exports.IncludeMatchToken = IncludeMatchToken;
class DashMatchToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = '|=';
  }
}
exports.DashMatchToken = DashMatchToken;
class PrefixMatchToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = '^=';
  }
}
exports.PrefixMatchToken = PrefixMatchToken;
class SuffixMatchToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = '$=';
  }
}
exports.SuffixMatchToken = SuffixMatchToken;
class SubstringMatchToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = '*=';
  }
}
exports.SubstringMatchToken = SubstringMatchToken;
class ColumnToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = '||';
  }
}
exports.ColumnToken = ColumnToken;
class EOFToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.tokenType = 'EOF';
  }
  toSource() {
    return '';
  }
}
exports.EOFToken = EOFToken;
class DelimToken extends CSSParserToken {
  constructor(code) {
    super();
    this.tokenType = 'DELIM';
    this.value = '';
    this.value = stringFromCode(code);
  }
  toString() {
    return 'DELIM(' + this.value + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    return json;
  }
  toSource() {
<<<<<<< HEAD
    if (this.value === "\\")
      return "\\\n";
    else
      return this.value;
  }
}
class StringValuedToken extends CSSParserToken {
  constructor() {
    super(...arguments);
    this.value = "";
=======
    if (this.value === '\\') return '\\\n';else return this.value;
  }
}
exports.DelimToken = DelimToken;
class StringValuedToken extends CSSParserToken {
  constructor(...args) {
    super(...args);
    this.value = '';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  ASCIIMatch(str) {
    return this.value.toLowerCase() === str.toLowerCase();
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    return json;
  }
}
<<<<<<< HEAD
class IdentToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = "IDENT";
    this.value = val;
  }
  toString() {
    return "IDENT(" + this.value + ")";
=======
exports.StringValuedToken = StringValuedToken;
class IdentToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = 'IDENT';
    this.value = val;
  }
  toString() {
    return 'IDENT(' + this.value + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toSource() {
    return escapeIdent(this.value);
  }
}
<<<<<<< HEAD
class FunctionToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = "FUNCTION";
    this.value = val;
    this.mirror = ")";
  }
  toString() {
    return "FUNCTION(" + this.value + ")";
  }
  toSource() {
    return escapeIdent(this.value) + "(";
  }
}
class AtKeywordToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = "AT-KEYWORD";
    this.value = val;
  }
  toString() {
    return "AT(" + this.value + ")";
  }
  toSource() {
    return "@" + escapeIdent(this.value);
  }
}
class HashToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = "HASH";
    this.value = val;
    this.type = "unrestricted";
  }
  toString() {
    return "HASH(" + this.value + ")";
=======
exports.IdentToken = IdentToken;
class FunctionToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = 'FUNCTION';
    this.mirror = void 0;
    this.value = val;
    this.mirror = ')';
  }
  toString() {
    return 'FUNCTION(' + this.value + ')';
  }
  toSource() {
    return escapeIdent(this.value) + '(';
  }
}
exports.FunctionToken = FunctionToken;
class AtKeywordToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = 'AT-KEYWORD';
    this.value = val;
  }
  toString() {
    return 'AT(' + this.value + ')';
  }
  toSource() {
    return '@' + escapeIdent(this.value);
  }
}
exports.AtKeywordToken = AtKeywordToken;
class HashToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = 'HASH';
    this.type = void 0;
    this.value = val;
    this.type = 'unrestricted';
  }
  toString() {
    return 'HASH(' + this.value + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.type = this.type;
    return json;
  }
  toSource() {
<<<<<<< HEAD
    if (this.type === "id")
      return "#" + escapeIdent(this.value);
    else
      return "#" + escapeHash(this.value);
  }
}
class StringToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = "STRING";
=======
    if (this.type === 'id') return '#' + escapeIdent(this.value);else return '#' + escapeHash(this.value);
  }
}
exports.HashToken = HashToken;
class StringToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = 'STRING';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this.value = val;
  }
  toString() {
    return '"' + escapeString(this.value) + '"';
  }
}
<<<<<<< HEAD
class URLToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = "URL";
    this.value = val;
  }
  toString() {
    return "URL(" + this.value + ")";
=======
exports.StringToken = StringToken;
class URLToken extends StringValuedToken {
  constructor(val) {
    super();
    this.tokenType = 'URL';
    this.value = val;
  }
  toString() {
    return 'URL(' + this.value + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toSource() {
    return 'url("' + escapeString(this.value) + '")';
  }
}
<<<<<<< HEAD
class NumberToken extends CSSParserToken {
  constructor() {
    super();
    this.tokenType = "NUMBER";
    this.type = "integer";
    this.repr = "";
  }
  toString() {
    if (this.type === "integer")
      return "INT(" + this.value + ")";
    return "NUMBER(" + this.value + ")";
=======
exports.URLToken = URLToken;
class NumberToken extends CSSParserToken {
  constructor() {
    super();
    this.tokenType = 'NUMBER';
    this.type = void 0;
    this.repr = void 0;
    this.type = 'integer';
    this.repr = '';
  }
  toString() {
    if (this.type === 'integer') return 'INT(' + this.value + ')';
    return 'NUMBER(' + this.value + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toJSON() {
    const json = super.toJSON();
    json.value = this.value;
    json.type = this.type;
    json.repr = this.repr;
    return json;
  }
  toSource() {
    return this.repr;
  }
}
<<<<<<< HEAD
class PercentageToken extends CSSParserToken {
  constructor() {
    super();
    this.tokenType = "PERCENTAGE";
    this.repr = "";
  }
  toString() {
    return "PERCENTAGE(" + this.value + ")";
=======
exports.NumberToken = NumberToken;
class PercentageToken extends CSSParserToken {
  constructor() {
    super();
    this.tokenType = 'PERCENTAGE';
    this.repr = void 0;
    this.repr = '';
  }
  toString() {
    return 'PERCENTAGE(' + this.value + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.repr = this.repr;
    return json;
  }
  toSource() {
<<<<<<< HEAD
    return this.repr + "%";
  }
}
class DimensionToken extends CSSParserToken {
  constructor() {
    super();
    this.tokenType = "DIMENSION";
    this.type = "integer";
    this.repr = "";
    this.unit = "";
  }
  toString() {
    return "DIM(" + this.value + "," + this.unit + ")";
=======
    return this.repr + '%';
  }
}
exports.PercentageToken = PercentageToken;
class DimensionToken extends CSSParserToken {
  constructor() {
    super();
    this.tokenType = 'DIMENSION';
    this.type = void 0;
    this.repr = void 0;
    this.unit = void 0;
    this.type = 'integer';
    this.repr = '';
    this.unit = '';
  }
  toString() {
    return 'DIM(' + this.value + ',' + this.unit + ')';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.type = this.type;
    json.repr = this.repr;
    json.unit = this.unit;
    return json;
  }
  toSource() {
    const source = this.repr;
    let unit = escapeIdent(this.unit);
<<<<<<< HEAD
    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {
      unit = "\\65 " + unit.slice(1, unit.length);
=======
    if (unit[0].toLowerCase() === 'e' && (unit[1] === '-' || between(unit.charCodeAt(1), 0x30, 0x39))) {
      // Unit is ambiguous with scinot
      // Remove the leading "e", replace with escape.
      unit = '\\65 ' + unit.slice(1, unit.length);
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    }
    return source + unit;
  }
}
<<<<<<< HEAD
function escapeIdent(string) {
  string = "" + string;
  let result = "";
  const firstcode = string.charCodeAt(0);
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)
      result += "\\" + code.toString(16) + " ";
    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
      result += string[i];
    else
      result += "\\" + string[i];
=======
exports.DimensionToken = DimensionToken;
function escapeIdent(string) {
  string = '' + string;
  let result = '';
  const firstcode = string.charCodeAt(0);
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code === 0x0) throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
    if (between(code, 0x1, 0x1f) || code === 0x7f || i === 0 && between(code, 0x30, 0x39) || i === 1 && between(code, 0x30, 0x39) && firstcode === 0x2d) result += '\\' + code.toString(16) + ' ';else if (code >= 0x80 || code === 0x2d || code === 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) result += string[i];else result += '\\' + string[i];
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  return result;
}
function escapeHash(string) {
<<<<<<< HEAD
  string = "" + string;
  let result = "";
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
      result += string[i];
    else
      result += "\\" + code.toString(16) + " ";
=======
  // Escapes the contents of "unrestricted"-type hash tokens.
  // Won't preserve the ID-ness of "id"-type hash tokens;
  // use escapeIdent() for that.
  string = '' + string;
  let result = '';
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code === 0x0) throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
    if (code >= 0x80 || code === 0x2d || code === 0x5f || between(code, 0x30, 0x39) || between(code, 0x41, 0x5a) || between(code, 0x61, 0x7a)) result += string[i];else result += '\\' + code.toString(16) + ' ';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  return result;
}
function escapeString(string) {
<<<<<<< HEAD
  string = "" + string;
  let result = "";
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (between(code, 1, 31) || code === 127)
      result += "\\" + code.toString(16) + " ";
    else if (code === 34 || code === 92)
      result += "\\" + string[i];
    else
      result += string[i];
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AtKeywordToken,
  BadStringToken,
  BadURLToken,
  CDCToken,
  CDOToken,
  CSSParserToken,
  CloseCurlyToken,
  CloseParenToken,
  CloseSquareToken,
  ColonToken,
  ColumnToken,
  CommaToken,
  DashMatchToken,
  DelimToken,
  DimensionToken,
  EOFToken,
  FunctionToken,
  GroupingToken,
  HashToken,
  IdentToken,
  IncludeMatchToken,
  InvalidCharacterError,
  NumberToken,
  OpenCurlyToken,
  OpenParenToken,
  OpenSquareToken,
  PercentageToken,
  PrefixMatchToken,
  SemicolonToken,
  StringToken,
  StringValuedToken,
  SubstringMatchToken,
  SuffixMatchToken,
  URLToken,
  WhitespaceToken,
  tokenize
});
=======
  string = '' + string;
  let result = '';
  for (let i = 0; i < string.length; i++) {
    const code = string.charCodeAt(i);
    if (code === 0x0) throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
    if (between(code, 0x1, 0x1f) || code === 0x7f) result += '\\' + code.toString(16) + ' ';else if (code === 0x22 || code === 0x5c) result += '\\' + string[i];else result += string[i];
  }
  return result;
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
