"use strict";
<<<<<<< HEAD
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var testTracing_exports = {};
__export(testTracing_exports, {
  TestTracing: () => TestTracing,
  testTraceEntryName: () => testTraceEntryName
});
module.exports = __toCommonJS(testTracing_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_utils = require("playwright-core/lib/utils");
var import_zipBundle = require("playwright-core/lib/zipBundle");
var import_util = require("../isomorphic/util");
var import_util2 = require("../util");
const testTraceEntryName = "test.trace";
=======

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testTraceEntryName = exports.TestTracing = void 0;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _utils = require("playwright-core/lib/utils");
var _zipBundle = require("playwright-core/lib/zipBundle");
var _util = require("../isomorphic/util");
var _util2 = require("../util");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const testTraceEntryName = exports.testTraceEntryName = 'test.trace';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
const version = 7;
let traceOrdinal = 0;
class TestTracing {
  constructor(testInfo, artifactsDir) {
<<<<<<< HEAD
    this._traceEvents = [];
    this._temporaryTraceFiles = [];
=======
    this._testInfo = void 0;
    this._options = void 0;
    this._liveTraceFile = void 0;
    this._traceEvents = [];
    this._temporaryTraceFiles = [];
    this._artifactsDir = void 0;
    this._tracesDir = void 0;
    this._contextCreatedEvent = void 0;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._didFinishTestFunctionAndAfterEachHooks = false;
    this._lastActionId = 0;
    this._testInfo = testInfo;
    this._artifactsDir = artifactsDir;
<<<<<<< HEAD
    this._tracesDir = import_path.default.join(this._artifactsDir, "traces");
    this._contextCreatedEvent = {
      version,
      type: "context-options",
      origin: "testRunner",
      browserName: "",
      options: {},
      platform: process.platform,
      wallTime: Date.now(),
      monotonicTime: (0, import_utils.monotonicTime)(),
      sdkLanguage: "javascript"
=======
    this._tracesDir = _path.default.join(this._artifactsDir, 'traces');
    this._contextCreatedEvent = {
      version,
      type: 'context-options',
      origin: 'testRunner',
      browserName: '',
      options: {},
      platform: process.platform,
      wallTime: Date.now(),
      monotonicTime: (0, _utils.monotonicTime)(),
      sdkLanguage: 'javascript'
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    };
    this._appendTraceEvent(this._contextCreatedEvent);
  }
  _shouldCaptureTrace() {
<<<<<<< HEAD
    if (process.env.PW_TEST_DISABLE_TRACING)
      return false;
    if (this._options?.mode === "on")
      return true;
    if (this._options?.mode === "retain-on-failure")
      return true;
    if (this._options?.mode === "on-first-retry" && this._testInfo.retry === 1)
      return true;
    if (this._options?.mode === "on-all-retries" && this._testInfo.retry > 0)
      return true;
    if (this._options?.mode === "retain-on-first-failure" && this._testInfo.retry === 0)
      return true;
    return false;
  }
  async startIfNeeded(value) {
    const defaultTraceOptions = { screenshots: true, snapshots: true, sources: true, attachments: true, _live: false, mode: "off" };
    if (!value) {
      this._options = defaultTraceOptions;
    } else if (typeof value === "string") {
      this._options = { ...defaultTraceOptions, mode: value === "retry-with-trace" ? "on-first-retry" : value };
    } else {
      const mode = value.mode || "off";
      this._options = { ...defaultTraceOptions, ...value, mode: mode === "retry-with-trace" ? "on-first-retry" : mode };
    }
    if (!this._shouldCaptureTrace()) {
      this._options = void 0;
      return;
    }
    if (!this._liveTraceFile && this._options._live) {
      this._liveTraceFile = { file: import_path.default.join(this._tracesDir, `${this._testInfo.testId}-test.trace`), fs: new import_utils.SerializedFS() };
      this._liveTraceFile.fs.mkdir(import_path.default.dirname(this._liveTraceFile.file));
      const data = this._traceEvents.map((e) => JSON.stringify(e)).join("\n") + "\n";
=======
    var _this$_options, _this$_options2, _this$_options3, _this$_options4, _this$_options5;
    if (process.env.PW_TEST_DISABLE_TRACING) return false;
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.mode) === 'on') return true;
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.mode) === 'retain-on-failure') return true;
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.mode) === 'on-first-retry' && this._testInfo.retry === 1) return true;
    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.mode) === 'on-all-retries' && this._testInfo.retry > 0) return true;
    if (((_this$_options5 = this._options) === null || _this$_options5 === void 0 ? void 0 : _this$_options5.mode) === 'retain-on-first-failure' && this._testInfo.retry === 0) return true;
    return false;
  }
  async startIfNeeded(value) {
    const defaultTraceOptions = {
      screenshots: true,
      snapshots: true,
      sources: true,
      attachments: true,
      _live: false,
      mode: 'off'
    };
    if (!value) {
      this._options = defaultTraceOptions;
    } else if (typeof value === 'string') {
      this._options = {
        ...defaultTraceOptions,
        mode: value === 'retry-with-trace' ? 'on-first-retry' : value
      };
    } else {
      const mode = value.mode || 'off';
      this._options = {
        ...defaultTraceOptions,
        ...value,
        mode: mode === 'retry-with-trace' ? 'on-first-retry' : mode
      };
    }
    if (!this._shouldCaptureTrace()) {
      this._options = undefined;
      return;
    }
    if (!this._liveTraceFile && this._options._live) {
      // Note that trace name must start with testId for live tracing to work.
      this._liveTraceFile = {
        file: _path.default.join(this._tracesDir, `${this._testInfo.testId}-test.trace`),
        fs: new _utils.SerializedFS()
      };
      this._liveTraceFile.fs.mkdir(_path.default.dirname(this._liveTraceFile.file));
      const data = this._traceEvents.map(e => JSON.stringify(e)).join('\n') + '\n';
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      this._liveTraceFile.fs.writeFile(this._liveTraceFile.file, data);
    }
  }
  didFinishTestFunctionAndAfterEachHooks() {
    this._didFinishTestFunctionAndAfterEachHooks = true;
  }
  artifactsDir() {
    return this._artifactsDir;
  }
  tracesDir() {
    return this._tracesDir;
  }
  traceTitle() {
<<<<<<< HEAD
    return [import_path.default.relative(this._testInfo.project.testDir, this._testInfo.file) + ":" + this._testInfo.line, ...this._testInfo.titlePath.slice(1)].join(" \u203A ");
  }
  generateNextTraceRecordingName() {
    const ordinalSuffix = traceOrdinal ? `-recording${traceOrdinal}` : "";
    ++traceOrdinal;
    const retrySuffix = this._testInfo.retry ? `-retry${this._testInfo.retry}` : "";
    return `${this._testInfo.testId}${retrySuffix}${ordinalSuffix}`;
  }
  _generateNextTraceRecordingPath() {
    const file = import_path.default.join(this._artifactsDir, (0, import_utils.createGuid)() + ".zip");
=======
    return [_path.default.relative(this._testInfo.project.testDir, this._testInfo.file) + ':' + this._testInfo.line, ...this._testInfo.titlePath.slice(1)].join(' â€º ');
  }
  generateNextTraceRecordingName() {
    const ordinalSuffix = traceOrdinal ? `-recording${traceOrdinal}` : '';
    ++traceOrdinal;
    const retrySuffix = this._testInfo.retry ? `-retry${this._testInfo.retry}` : '';
    // Note that trace name must start with testId for live tracing to work.
    return `${this._testInfo.testId}${retrySuffix}${ordinalSuffix}`;
  }
  _generateNextTraceRecordingPath() {
    const file = _path.default.join(this._artifactsDir, (0, _utils.createGuid)() + '.zip');
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    this._temporaryTraceFiles.push(file);
    return file;
  }
  traceOptions() {
    return this._options;
  }
  maybeGenerateNextTraceRecordingPath() {
<<<<<<< HEAD
    if (this._didFinishTestFunctionAndAfterEachHooks && this._shouldAbandonTrace())
      return;
    return this._generateNextTraceRecordingPath();
  }
  _shouldAbandonTrace() {
    if (!this._options)
      return true;
    const testFailed = this._testInfo.status !== this._testInfo.expectedStatus;
    return !testFailed && (this._options.mode === "retain-on-failure" || this._options.mode === "retain-on-first-failure");
  }
  async stopIfNeeded() {
    if (!this._options)
      return;
    const error = await this._liveTraceFile?.fs.syncAndGetError();
    if (error)
      throw error;
    if (this._shouldAbandonTrace()) {
      for (const file of this._temporaryTraceFiles)
        await import_fs.default.promises.unlink(file).catch(() => {
        });
      return;
    }
    const zipFile = new import_zipBundle.yazl.ZipFile();
    if (!this._options?.attachments) {
      for (const event of this._traceEvents) {
        if (event.type === "after")
          delete event.attachments;
      }
    }
    if (this._options?.sources) {
      const sourceFiles = /* @__PURE__ */ new Set();
      for (const event of this._traceEvents) {
        if (event.type === "before") {
          for (const frame of event.stack || [])
            sourceFiles.add(frame.file);
        }
      }
      for (const sourceFile of sourceFiles) {
        await import_fs.default.promises.readFile(sourceFile, "utf8").then((source) => {
          zipFile.addBuffer(Buffer.from(source), "resources/src@" + (0, import_utils.calculateSha1)(sourceFile) + ".txt");
        }).catch(() => {
        });
      }
    }
    const sha1s = /* @__PURE__ */ new Set();
    for (const event of this._traceEvents.filter((e) => e.type === "after")) {
      for (const attachment of event.attachments || []) {
        let contentPromise;
        if (attachment.path)
          contentPromise = import_fs.default.promises.readFile(attachment.path).catch(() => void 0);
        else if (attachment.base64)
          contentPromise = Promise.resolve(Buffer.from(attachment.base64, "base64"));
        const content = await contentPromise;
        if (content === void 0)
          continue;
        const sha1 = (0, import_utils.calculateSha1)(content);
        attachment.sha1 = sha1;
        delete attachment.path;
        delete attachment.base64;
        if (sha1s.has(sha1))
          continue;
        sha1s.add(sha1);
        zipFile.addBuffer(content, "resources/" + sha1);
      }
    }
    const traceContent = Buffer.from(this._traceEvents.map((e) => JSON.stringify(e)).join("\n"));
    zipFile.addBuffer(traceContent, testTraceEntryName);
    await new Promise((f) => {
      zipFile.end(void 0, () => {
        zipFile.outputStream.pipe(import_fs.default.createWriteStream(this._generateNextTraceRecordingPath())).on("close", f);
      });
    });
    const tracePath = this._testInfo.outputPath("trace.zip");
    await mergeTraceFiles(tracePath, this._temporaryTraceFiles);
    this._testInfo.attachments.push({ name: "trace", path: tracePath, contentType: "application/zip" });
  }
  appendForError(error) {
    const rawStack = error.stack?.split("\n") || [];
    const stack = rawStack ? (0, import_util2.filteredStackTrace)(rawStack) : [];
    this._appendTraceEvent({
      type: "error",
=======
    // Forget about traces that should be saved on failure, when no failure happened
    // during the test and beforeEach/afterEach hooks.
    // This avoids downloading traces over the wire when not really needed.
    if (this._didFinishTestFunctionAndAfterEachHooks && this._shouldAbandonTrace()) return;
    return this._generateNextTraceRecordingPath();
  }
  _shouldAbandonTrace() {
    if (!this._options) return true;
    const testFailed = this._testInfo.status !== this._testInfo.expectedStatus;
    return !testFailed && (this._options.mode === 'retain-on-failure' || this._options.mode === 'retain-on-first-failure');
  }
  async stopIfNeeded() {
    var _this$_liveTraceFile, _this$_options6, _this$_options7;
    if (!this._options) return;
    const error = await ((_this$_liveTraceFile = this._liveTraceFile) === null || _this$_liveTraceFile === void 0 ? void 0 : _this$_liveTraceFile.fs.syncAndGetError());
    if (error) throw error;
    if (this._shouldAbandonTrace()) {
      for (const file of this._temporaryTraceFiles) await _fs.default.promises.unlink(file).catch(() => {});
      return;
    }
    const zipFile = new _zipBundle.yazl.ZipFile();
    if (!((_this$_options6 = this._options) !== null && _this$_options6 !== void 0 && _this$_options6.attachments)) {
      for (const event of this._traceEvents) {
        if (event.type === 'after') delete event.attachments;
      }
    }
    if ((_this$_options7 = this._options) !== null && _this$_options7 !== void 0 && _this$_options7.sources) {
      const sourceFiles = new Set();
      for (const event of this._traceEvents) {
        if (event.type === 'before') {
          for (const frame of event.stack || []) sourceFiles.add(frame.file);
        }
      }
      for (const sourceFile of sourceFiles) {
        await _fs.default.promises.readFile(sourceFile, 'utf8').then(source => {
          zipFile.addBuffer(Buffer.from(source), 'resources/src@' + (0, _utils.calculateSha1)(sourceFile) + '.txt');
        }).catch(() => {});
      }
    }
    const sha1s = new Set();
    for (const event of this._traceEvents.filter(e => e.type === 'after')) {
      for (const attachment of event.attachments || []) {
        let contentPromise;
        if (attachment.path) contentPromise = _fs.default.promises.readFile(attachment.path).catch(() => undefined);else if (attachment.base64) contentPromise = Promise.resolve(Buffer.from(attachment.base64, 'base64'));
        const content = await contentPromise;
        if (content === undefined) continue;
        const sha1 = (0, _utils.calculateSha1)(content);
        attachment.sha1 = sha1;
        delete attachment.path;
        delete attachment.base64;
        if (sha1s.has(sha1)) continue;
        sha1s.add(sha1);
        zipFile.addBuffer(content, 'resources/' + sha1);
      }
    }
    const traceContent = Buffer.from(this._traceEvents.map(e => JSON.stringify(e)).join('\n'));
    zipFile.addBuffer(traceContent, testTraceEntryName);
    await new Promise(f => {
      zipFile.end(undefined, () => {
        zipFile.outputStream.pipe(_fs.default.createWriteStream(this._generateNextTraceRecordingPath())).on('close', f);
      });
    });
    const tracePath = this._testInfo.outputPath('trace.zip');
    await mergeTraceFiles(tracePath, this._temporaryTraceFiles);
    this._testInfo.attachments.push({
      name: 'trace',
      path: tracePath,
      contentType: 'application/zip'
    });
  }
  appendForError(error) {
    var _error$stack;
    const rawStack = ((_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : _error$stack.split('\n')) || [];
    const stack = rawStack ? (0, _util2.filteredStackTrace)(rawStack) : [];
    this._appendTraceEvent({
      type: 'error',
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      message: this._formatError(error),
      stack
    });
  }
  _formatError(error) {
    const parts = [error.message || String(error.value)];
<<<<<<< HEAD
    if (error.cause)
      parts.push("[cause]: " + this._formatError(error.cause));
    return parts.join("\n");
=======
    if (error.cause) parts.push('[cause]: ' + this._formatError(error.cause));
    return parts.join('\n');
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
  }
  appendStdioToTrace(type, chunk) {
    this._appendTraceEvent({
      type,
<<<<<<< HEAD
      timestamp: (0, import_utils.monotonicTime)(),
      text: typeof chunk === "string" ? chunk : void 0,
      base64: typeof chunk === "string" ? void 0 : chunk.toString("base64")
=======
      timestamp: (0, _utils.monotonicTime)(),
      text: typeof chunk === 'string' ? chunk : undefined,
      base64: typeof chunk === 'string' ? undefined : chunk.toString('base64')
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    });
  }
  appendBeforeActionForStep(callId, parentId, category, apiName, params, stack) {
    this._appendTraceEvent({
<<<<<<< HEAD
      type: "before",
      callId,
      parentId,
      startTime: (0, import_utils.monotonicTime)(),
      class: "Test",
      method: "step",
=======
      type: 'before',
      callId,
      parentId,
      startTime: (0, _utils.monotonicTime)(),
      class: 'Test',
      method: 'step',
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      apiName,
      params: Object.fromEntries(Object.entries(params || {}).map(([name, value]) => [name, generatePreview(value)])),
      stack
    });
  }
  appendAfterActionForStep(callId, error, attachments = [], annotations) {
    this._appendTraceEvent({
<<<<<<< HEAD
      type: "after",
      callId,
      endTime: (0, import_utils.monotonicTime)(),
=======
      type: 'after',
      callId,
      endTime: (0, _utils.monotonicTime)(),
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      attachments: serializeAttachments(attachments),
      annotations,
      error
    });
  }
  appendTopLevelAttachment(attachment) {
<<<<<<< HEAD
    const callId = `${import_util.kTopLevelAttachmentPrefix}@${++this._lastActionId}`;
    this.appendBeforeActionForStep(callId, void 0, import_util.kTopLevelAttachmentPrefix, `${import_util.kTopLevelAttachmentPrefix} "${attachment.name}"`, void 0, []);
    this.appendAfterActionForStep(callId, void 0, [attachment]);
  }
  _appendTraceEvent(event) {
    this._traceEvents.push(event);
    if (this._liveTraceFile)
      this._liveTraceFile.fs.appendFile(this._liveTraceFile.file, JSON.stringify(event) + "\n", true);
  }
}
function serializeAttachments(attachments) {
  if (attachments.length === 0)
    return void 0;
  return attachments.filter((a) => a.name !== "trace").map((a) => {
=======
    // trace viewer has no means of representing attachments outside of a step,
    // so we create an artificial action that's hidden in the UI
    // the alternative would be to have one hidden step at the end with all top-level attachments,
    // but that would delay useful information in live traces.
    const callId = `${_util.kTopLevelAttachmentPrefix}@${++this._lastActionId}`;
    this.appendBeforeActionForStep(callId, undefined, _util.kTopLevelAttachmentPrefix, `${_util.kTopLevelAttachmentPrefix} "${attachment.name}"`, undefined, []);
    this.appendAfterActionForStep(callId, undefined, [attachment]);
  }
  _appendTraceEvent(event) {
    this._traceEvents.push(event);
    if (this._liveTraceFile) this._liveTraceFile.fs.appendFile(this._liveTraceFile.file, JSON.stringify(event) + '\n', true);
  }
}
exports.TestTracing = TestTracing;
function serializeAttachments(attachments) {
  if (attachments.length === 0) return undefined;
  return attachments.filter(a => a.name !== 'trace').map(a => {
    var _a$body;
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
    return {
      name: a.name,
      contentType: a.contentType,
      path: a.path,
<<<<<<< HEAD
      base64: a.body?.toString("base64")
    };
  });
}
function generatePreview(value, visited = /* @__PURE__ */ new Set()) {
  if (visited.has(value))
    return "";
  visited.add(value);
  if (typeof value === "string")
    return value;
  if (typeof value === "number")
    return value.toString();
  if (typeof value === "boolean")
    return value.toString();
  if (value === null)
    return "null";
  if (value === void 0)
    return "undefined";
  if (Array.isArray(value))
    return "[" + value.map((v) => generatePreview(v, visited)).join(", ") + "]";
  if (typeof value === "object")
    return "Object";
  return String(value);
}
async function mergeTraceFiles(fileName, temporaryTraceFiles) {
  temporaryTraceFiles = temporaryTraceFiles.filter((file) => import_fs.default.existsSync(file));
  if (temporaryTraceFiles.length === 1) {
    await import_fs.default.promises.rename(temporaryTraceFiles[0], fileName);
    return;
  }
  const mergePromise = new import_utils.ManualPromise();
  const zipFile = new import_zipBundle.yazl.ZipFile();
  const entryNames = /* @__PURE__ */ new Set();
  zipFile.on("error", (error) => mergePromise.reject(error));
  for (let i = temporaryTraceFiles.length - 1; i >= 0; --i) {
    const tempFile = temporaryTraceFiles[i];
    const promise = new import_utils.ManualPromise();
    import_zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
=======
      base64: (_a$body = a.body) === null || _a$body === void 0 ? void 0 : _a$body.toString('base64')
    };
  });
}
function generatePreview(value, visited = new Set()) {
  if (visited.has(value)) return '';
  visited.add(value);
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return value.toString();
  if (typeof value === 'boolean') return value.toString();
  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  if (Array.isArray(value)) return '[' + value.map(v => generatePreview(v, visited)).join(', ') + ']';
  if (typeof value === 'object') return 'Object';
  return String(value);
}
async function mergeTraceFiles(fileName, temporaryTraceFiles) {
  temporaryTraceFiles = temporaryTraceFiles.filter(file => _fs.default.existsSync(file));
  if (temporaryTraceFiles.length === 1) {
    await _fs.default.promises.rename(temporaryTraceFiles[0], fileName);
    return;
  }
  const mergePromise = new _utils.ManualPromise();
  const zipFile = new _zipBundle.yazl.ZipFile();
  const entryNames = new Set();
  zipFile.on('error', error => mergePromise.reject(error));
  for (let i = temporaryTraceFiles.length - 1; i >= 0; --i) {
    const tempFile = temporaryTraceFiles[i];
    const promise = new _utils.ManualPromise();
    _zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
      if (err) {
        promise.reject(err);
        return;
      }
      let pendingEntries = inZipFile.entryCount;
<<<<<<< HEAD
      inZipFile.on("entry", (entry) => {
        let entryName = entry.fileName;
        if (entry.fileName === testTraceEntryName) {
        } else if (entry.fileName.match(/trace\.[a-z]*$/)) {
          entryName = i + "-" + entry.fileName;
        }
        if (entryNames.has(entryName)) {
          if (--pendingEntries === 0)
            promise.resolve();
          return;
        }
        entryNames.add(entryName);
        inZipFile.openReadStream(entry, (err2, readStream) => {
          if (err2) {
            promise.reject(err2);
            return;
          }
          zipFile.addReadStream(readStream, entryName);
          if (--pendingEntries === 0)
            promise.resolve();
=======
      inZipFile.on('entry', entry => {
        let entryName = entry.fileName;
        if (entry.fileName === testTraceEntryName) {
          // Keep the name for test traces so that the last test trace
          // that contains most of the information is kept in the trace.
          // Note the reverse order of the iteration (from new traces to old).
        } else if (entry.fileName.match(/trace\.[a-z]*$/)) {
          entryName = i + '-' + entry.fileName;
        }
        if (entryNames.has(entryName)) {
          if (--pendingEntries === 0) promise.resolve();
          return;
        }
        entryNames.add(entryName);
        inZipFile.openReadStream(entry, (err, readStream) => {
          if (err) {
            promise.reject(err);
            return;
          }
          zipFile.addReadStream(readStream, entryName);
          if (--pendingEntries === 0) promise.resolve();
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
        });
      });
    });
    await promise;
  }
<<<<<<< HEAD
  zipFile.end(void 0, () => {
    zipFile.outputStream.pipe(import_fs.default.createWriteStream(fileName)).on("close", () => {
      void Promise.all(temporaryTraceFiles.map((tempFile) => import_fs.default.promises.unlink(tempFile))).then(() => {
        mergePromise.resolve();
      }).catch((error) => mergePromise.reject(error));
    }).on("error", (error) => mergePromise.reject(error));
  });
  await mergePromise;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  TestTracing,
  testTraceEntryName
});
=======
  zipFile.end(undefined, () => {
    zipFile.outputStream.pipe(_fs.default.createWriteStream(fileName)).on('close', () => {
      void Promise.all(temporaryTraceFiles.map(tempFile => _fs.default.promises.unlink(tempFile))).then(() => {
        mergePromise.resolve();
      }).catch(error => mergePromise.reject(error));
    }).on('error', error => mergePromise.reject(error));
  });
  await mergePromise;
}
>>>>>>> 0bbb606fffa4286e884fc3bf9391c67f4bdb0fbb
